# 3.1.2 Abstract Factory

## **1. Padrão GOF Abstract Factory**

O padrão de projeto **Abstract Factory** é um padrão criacional que fornece uma interface para criar famílias de objetos relacionados ou dependentes sem especificar suas classes concretas. Ele é utilizado quando um sistema precisa ser independente de como seus produtos são criados, compostos e representados.

A intenção principal do Abstract Factory é isolar o cliente das classes concretas dos objetos que ele precisa criar. Em vez de instanciar objetos diretamente, o cliente utiliza a fábrica abstrata, que por sua vez delega a criação para uma de suas subclasses (as fábricas concretas), garantindo que os objetos criados sejam de uma mesma família e, portanto, compatíveis entre si.

Isso é particularmente útil em cenários onde o sistema precisa ser configurado com uma de múltiplas famílias de produtos. A troca de uma família por outra se torna simples, exigindo apenas a troca da instância da fábrica concreta utilizada pelo cliente, o que está em conformidade com o princípio de aberto/fechado (SOLID).

## **2. Metodologia**

A aplicação do padrão Abstract Factory foi planejada em quatro etapas, partindo da análise do domínio e culminando na implementação.

1.  **Análise do Domínio**: O primeiro passo foi analisar o diagrama de classes do projeto "AquiTemFCTE" e o contexto de negócio. Identificou-se que a classe `Produto` pode ser agrupada em diferentes *famílias* com base em sua `categoria` (Eletrônicos, Roupas, Móveis, etc.). Além do produto em si, cada família pode ter objetos associados, como uma `Garantia` para eletrônicos ou uma `TabelaDeMedidas` para roupas. Essa necessidade de criar conjuntos de objetos relacionados tornou o Abstract Factory uma escolha ideal.

2.  **Modelagem da Solução**: O segundo passo foi modelar a estrutura do padrão. Isso envolveu a definição de uma interface para a fábrica abstrata (`IProdutoFactory`), interfaces para os produtos abstratos (`IProduto`, `IAcessorio`) e as classes concretas para cada família de produtos (e.g., `EletronicoFactory`, `ProdutoEletronico`, `Garantia`).

3.  **Seleção de Tecnologias**: Para a implementação, optou-se por utilizar **TypeScript** com **Node.js** e o framework **Express**. O TypeScript foi escolhido por sua tipagem forte, que oferece robustez na implementação de padrões de projeto.

4.  **Implementação e Testes**: A etapa final foi a codificação da arquitetura planejada e a criação de endpoints na camada de serviço para testar a criação das diferentes famílias de produtos através de requisições HTTP.

## **3. Modelagem do Abstract Factory**

A modelagem define a estrutura das fábricas e dos produtos. O sistema terá:
* **AbstractFactory (`IProdutoFactory`)**: Interface que define os métodos para criar os produtos de uma família (e.g., `criarProduto()`, `criarAcessorio()`).
* **ConcreteFactory (`EletronicoFactory`, `VestuarioFactory`)**: Classes que implementam a `IProdutoFactory` para criar uma família específica de produtos. A `EletronicoFactory`, por exemplo, criará instâncias de `ProdutoEletronico` e `Garantia`.
* **AbstractProduct (`IProduto`, `IAcessorio`)**: Interfaces que definem os tipos de produtos que podem ser criados.
* **ConcreteProduct (`ProdutoEletronico`, `Garantia`, `ProdutoVestuario`)**: As implementações concretas dos produtos que pertencem a uma família.

## **4. Informações Técnicas e Implementação**

### **4.1. Tecnologias Utilizadas**
* **TypeScript (v5.6.3)**: Linguagem principal para a implementação.
* **Node.js**: Ambiente de execução para o servidor.
* **Express.js (v4.19.2)**: Framework para a criação da API REST.
* **ts-node (v10.9.2)**: Ferramenta para execução de arquivos TypeScript.
* **Nodemon (v3.1.10)**: Utilitário para desenvolvimento com hot reload.

### **4.2. Estrutura da Implementação**
A implementação foi organizada na seguinte estrutura de arquivos e diretórios:

```
src/
├── factories/
│   ├── concrete/
│   │   ├── EletronicoFactory.ts
│   │   └── VestuarioFactory.ts
│   └── interfaces/
│       └── IProdutoFactory.ts
├── products/
│   ├── concrete/
│   │   ├── acessorios/
│   │   │   ├── Garantia.ts
│   │   │   └── TabelaDeMedidas.ts
│   │   ├── ProdutoEletronico.ts
│   │   └── ProdutoVestuario.ts
│   └── interfaces/
│       ├── IAcessorio.ts
│       └── IProduto.ts
├── services/
│   └── ProdutoService.ts
└── index.ts
```

#### **4.2.1. Interfaces dos Produtos Abstratos (`AbstractProduct`)**

Estas interfaces definem o contrato para os produtos que as fábricas criarão.

**`src/products/interfaces/IProduto.ts`**
```typescript
export default interface IProduto {
    nome: string;
    descricao: string;
    preco: number;
    categoria: string;

    exibirDetalhes(): void;
}
```

**`src/products/interfaces/IAcessorio.ts`**
```typescript
export default interface IAcessorio {
    nome: string;
    descricao: string;
}
```
**Explicação:** `IProduto` e `IAcessorio` desacoplam o cliente das implementações concretas. O cliente interage com os objetos apenas através dessas interfaces, sem conhecer as classes `ProdutoEletronico` ou `Garantia`.

---
#### **4.2.2. Interface da Fábrica Abstrata (`AbstractFactory`)**
Esta interface é o contrato que todas as fábricas concretas devem seguir.

**`src/factories/interfaces/IProdutoFactory.ts`**
```typescript
import IProduto from "../../products/interfaces/IProduto";
import IAcessorio from "../../products/interfaces/IAcessorio";

export default interface IProdutoFactory {
    criarProduto(nome: string, descricao: string, preco: number): IProduto;
    criarAcessorio(): IAcessorio;
}
```
**Explicação:** `IProdutoFactory` declara os métodos de criação para cada tipo de produto da família. O cliente usará esta interface para solicitar a criação de objetos, sem saber qual fábrica concreta está em uso.

---
#### **4.2.3. Implementações Concretas (`ConcreteProduct` e `ConcreteFactory`)**

Classes que implementam as interfaces para as famílias "Eletrônicos" e "Vestuário".

**`src/products/concrete/ProdutoEletronico.ts`**
```typescript
import IProduto from "../interfaces/IProduto";

export default class ProdutoEletronico implements IProduto {
    public categoria: string = "Eletrônicos";
    constructor(
        public nome: string,
        public descricao: string,
        public preco: number
    ) {}

    exibirDetalhes(): void {
        console.log(`Eletrônico: ${this.nome} - R$${this.preco}`);
    }
}
```

**`src/products/concrete/acessorios/Garantia.ts`**
```typescript
import IAcessorio from "../../interfaces/IAcessorio";

export default class Garantia implements IAcessorio {
    nome: string = "Garantia Estendida";
    descricao: string = "Cobertura de 12 meses para defeitos de fabricação.";
}
```

**`src/factories/concrete/EletronicoFactory.ts`**
```typescript
import IProdutoFactory from "../interfaces/IProdutoFactory";
import IProduto from "../../products/interfaces/IProduto";
import IAcessorio from "../../products/interfaces/IAcessorio";
import ProdutoEletronico from "../../products/concrete/ProdutoEletronico";
import Garantia from "../../products/concrete/acessorios/Garantia";

export default class EletronicoFactory implements IProdutoFactory {
    public criarProduto(nome: string, descricao: string, preco: number): IProduto {
        return new ProdutoEletronico(nome, descricao, preco);
    }

    public criarAcessorio(): IAcessorio {
        return new Garantia();
    }
}
```
**(As implementações para `ProdutoVestuario`, `TabelaDeMedidas` e `VestuarioFactory` seguiriam a mesma estrutura.)**

**Explicação:** Cada fábrica concreta (`EletronicoFactory`) é responsável por instanciar uma família específica de produtos (`ProdutoEletronico` e `Garantia`). Isso garante que os produtos criados sejam sempre compatíveis entre si.

---
#### **4.2.4. Camada de Serviço (`Client`)**
A classe `ProdutoService` atua como o cliente do padrão. Ela utiliza a fábrica para criar produtos com base nos dados de uma requisição HTTP.

**`src/services/ProdutoService.ts`**
```typescript
import { Router, Request, Response } from "express";
import IProdutoFactory from "../factories/interfaces/IProdutoFactory";
import EletronicoFactory from "../factories/concrete/EletronicoFactory";
import VestuarioFactory from "../factories/concrete/VestuarioFactory";

const router = Router();

export default class ProdutoService {
    public router: Router;

    constructor() {
        this.router = router;
        this.configurarRotas();
    }

    private configurarRotas(): void {
        this.router.post("/produto", (req: Request, res: Response) => {
            try {
                const { nome, descricao, preco, categoria } = req.body;

                let factory: IProdutoFactory;

                // Seleciona a fábrica com base na categoria
                if (categoria === "Eletrônicos") {
                    factory = new EletronicoFactory();
                } else if (categoria === "Vestuário") {
                    factory = new VestuarioFactory();
                } else {
                    return res.status(400).send({ error: "Categoria de produto inválida ou não suportada." });
                }

                // Usa a fábrica para criar a família de produtos
                const produto = factory.criarProduto(nome, descricao, preco);
                const acessorio = factory.criarAcessorio();

                res.status(201).send({ produto, acessorio });

            } catch (error) {
                res.status(500).send({ error: "Erro interno no servidor." });
            }
        });
    }
}
```
**Explicação:** O `ProdutoService` recebe uma requisição, determina qual fábrica concreta utilizar com base no campo `categoria`, e orquestra a criação da família de produtos. O cliente está completamente desacoplado das classes concretas dos produtos.

## **5. Como Executar a Implementação**

### **5.1. Pré-requisitos**
* Node.js (versão 16 ou superior)
* npm (gerenciador de pacotes do Node.js)
* Postman (ou similar) para testar os endpoints.

### **5.2. Passos para Execução**
**Passo 1:** Navegue até o diretório do projeto.

**Passo 2:** Instale as dependências.
```bash
npm install
```

**Passo 3:** Execute o servidor.
```bash
npm start
```

### **5.3. Testando a API com o Postman**

#### **Criação de Produto da Família "Eletrônicos"**
* **Método**: `POST`
* **URL**: `http://localhost:3001/produto`
* **Headers**: `Content-Type: application/json`
* **Body (JSON)**:
    ```json
    {
        "nome": "Smartphone Galaxy S30",
        "descricao": "Celular de última geração com 256GB.",
        "preco": 4500.00,
        "categoria": "Eletrônicos"
    }
    ```
* **Resposta Esperada (201 Created)**:
    ```json
    {
        "produto": {
            "categoria": "Eletrônicos",
            "nome": "Smartphone Galaxy S30",
            "descricao": "Celular de última geração com 256GB.",
            "preco": 4500
        },
        "acessorio": {
            "nome": "Garantia Estendida",
            "descricao": "Cobertura de 12 meses para defeitos de fabricação."
        }
    }
    ```

## **6. Conclusão**

A implementação do padrão **Abstract Factory** no projeto "AquiTemFCTE" demonstrou ser uma abordagem eficaz para gerenciar a criação de famílias de objetos complexos e relacionados. Enquanto o padrão **Builder** é excelente para controlar o processo de construção de um único objeto passo a passo, o Abstract Factory se destaca ao garantir a consistência entre múltiplos objetos que precisam ser criados juntos.

A solução permitiu isolar completamente o código cliente das classes concretas, facilitando a adição de novas famílias de produtos no futuro (como "Móveis" ou "Livros") sem a necessidade de alterar o código cliente existente, o que reforça a manutenibilidade e escalabilidade do software.