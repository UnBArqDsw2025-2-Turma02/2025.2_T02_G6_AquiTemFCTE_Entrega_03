# 3.1.4. Abstract Factory

## **1. Padrão GOF Abstract Factory**

O padrão de projeto **Abstract Factory** é um padrão criacional que fornece uma interface para criar famílias de objetos relacionados ou dependentes sem especificar suas classes concretas. Ele é utilizado quando um sistema precisa ser independente de como seus produtos são criados, compostos e representados.

A intenção principal do Abstract Factory é isolar o cliente das classes concretas dos objetos que ele precisa criar. Em vez de instanciar objetos diretamente, o cliente utiliza a fábrica abstrata, que por sua vez delega a criação para uma de suas subclasses (as fábricas concretas), garantindo que os objetos criados sejam de uma mesma família e, portanto, compatíveis entre si.

Isso é particularmente útil em cenários onde o sistema precisa ser configurado com uma de múltiplas famílias de produtos. A troca de uma família por outra se torna simples, exigindo apenas a troca da instância da fábrica concreta utilizada pelo cliente, o que está em conformidade com o princípio de aberto/fechado (SOLID).

## **2. Metodologia**

A aplicação do padrão Abstract Factory foi planejada em quatro etapas, partindo da análise do domínio e culminando na implementação.

1.  **Análise do Domínio**: O primeiro passo foi analisar o diagrama de classes do projeto "AquiTemFCTE" e o contexto de negócio. Identificou-se que a classe `Produto` pode ser agrupada em diferentes *famílias* com base em sua `categoria` (Eletrônicos, Roupas, Móveis, etc.). Além do produto em si, cada família pode ter objetos associados, como uma `Garantia` para eletrônicos ou uma `TabelaDeMedidas` para roupas. Essa necessidade de criar conjuntos de objetos relacionados tornou o Abstract Factory uma escolha ideal.

2.  **Modelagem da Solução**: O segundo passo foi modelar a estrutura do padrão. Isso envolveu a definição de uma interface para a fábrica abstrata (`InterfaceProdutoFactory`), interfaces para os produtos abstratos (`InterfaceProduto`, `InterfaceAcessorio`) e as classes concretas para cada família de produtos (e.g., `EletronicoFactory`, `ProdutoEletronico`, `Garantia`).

3.  **Seleção de Tecnologias**: Para a implementação, optou-se por utilizar **TypeScript** com **Node.js** e o framework **Express**. O TypeScript foi escolhido por sua tipagem forte, que oferece robustez na implementação de padrões de projeto.

4.  **Implementação e Testes**: A etapa final foi a codificação da arquitetura planejada e a criação de endpoints na camada de serviço para testar a criação das diferentes famílias de produtos através de requisições HTTP.

## **3. Modelagem do Abstract Factory**

<font size="2"><p style="text-align: center"><b>Figura 1:</b> Diagrama do Abstract Factory</p></font>

![diagrama_abstract_factory](/../assets/AbstractFactory.png)

<font size="2"><p style="text-align: center"><b>Fonte:</b> Caio Sabino e Davi Camilo</p></font>

A modelagem define a estrutura das fábricas e dos produtos. O sistema terá:
* **AbstractFactory (`InterfaceProdutoFactory`)**: Interface que define os métodos para criar os produtos de uma família (e.g., `criarProduto()`, `criarAcessorio()`).
* **ConcreteFactory (`EletronicoFactory`, `VestuarioFactory`)**: Classes que implementam a `InterfaceProdutoFactory` para criar uma família específica de produtos. A `EletronicoFactory`, por exemplo, criará instâncias de `ProdutoEletronico` e `Garantia`.
* **AbstractProduct (`InterfaceProduto`, `InterfaceAcessorio`)**: Interfaces que definem os tipos de produtos que podem ser criados.
* **ConcreteProduct (`ProdutoEletronico`, `Garantia`, `ProdutoVestuario`)**: As implementações concretas dos produtos que pertencem a uma família.

## Vídeo

<font size="2"><p style="text-align: center">Vídeo 1 - Código Abstract Factory.</p></font>

<center>
<iframe 
  width="560" 
  height="315" 
  src="https://www.youtube.com/embed/6ri3vGZbQnk" 
  title="Abstract Factory - AquiTemFCTE" 
  frameborder="0" 
  allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" 
  allowfullscreen>
</iframe>
</center>

<font size="2"><p style="text-align: center">Autor: [Caio Sabino](https://github.com/caiomsabino), 2025.</p></font>

**Link: https://youtu.be/6ri3vGZbQnk**

## **4. Informações Técnicas e Implementação**

### **4.1. Tecnologias Utilizadas**
* **TypeScript (v5.6.3)**: Linguagem principal para a implementação.
* **Node.js**: Ambiente de execução para o servidor.
* **Express.js (v4.19.2)**: Framework para a criação da API REST.
* **ts-node (v10.9.2)**: Ferramenta para execução de arquivos TypeScript.
* **Nodemon (v3.1.10)**: Utilitário para desenvolvimento com hot reload.

### **4.2. Estrutura da Implementação**
A implementação foi organizada na seguinte estrutura de arquivos e diretórios:

```
src/
├── factories/
│   ├── concrete/
│   │   ├── EletronicoFactory.ts
│   │   └── VestuarioFactory.ts
│   └── interfaces/
│       └── AbstractProdutoFactory.ts
├── products/
│   ├── concrete/
│   │   ├── acessorios/
│   │   │   ├── Garantia.ts
│   │   │   └── TabelaDeMedidas.ts
│   │   ├── ProdutoEletronico.ts
│   │   └── ProdutoVestuario.ts
│   └── interfaces/
│       ├── InterfaceAcessorio.ts
│       └── InterfaceProduto.ts
├── services/
│   └── ProdutoService.ts
└── index.ts
```

#### **4.2.1. Interfaces dos Produtos Abstratos (`AbstractProduct`)**

Estas interfaces definem o contrato para os produtos que as fábricas criarão.

**`src/products/interfaces/InterfaceProduto.ts`**
```typescript
export default interface InterfaceProduto {
    nome: string;
    descricao: string;
    preco: number;
    categoria: string;

    exibirDetalhes(): void;
}
```

**`src/products/interfaces/InterfaceAcessorio.ts`**
```typescript
export default interface InterfaceAcessorio {
    nome: string;
    descricao: string;
}
```
**Explicação:** `InterfaceProduto` e `InterfaceAcessorio` desacoplam o cliente das implementações concretas. O cliente interage com os objetos apenas através dessas interfaces, sem conhecer as classes `ProdutoEletronico` ou `Garantia`.

---
#### **4.2.2. Interface da Fábrica Abstrata (`AbstractFactory`)**
Esta interface é o contrato que todas as fábricas concretas devem seguir.

**`src/factories/interfaces/InterfaceProdutoFactory.ts`**
```typescript
import InterfaceProduto from "../../products/interfaces/InterfaceProduto";
import InterfaceAcessorio from "../../products/interfaces/InterfaceAcessorio";

export default interface InterfaceProdutoFactory {
    criarProduto(nome: string, descricao: string, preco: number): InterfaceProduto;
    criarAcessorio(): InterfaceAcessorio;
}
```
**Explicação:** `InterfaceProdutoFactory` declara os métodos de criação para cada tipo de produto da família. O cliente usará esta interface para solicitar a criação de objetos, sem saber qual fábrica concreta está em uso.

---
#### **4.2.3. Implementações Concretas (`ConcreteProduct` e `ConcreteFactory`)**

Classes que implementam as interfaces para as famílias "Eletrônicos" e "Vestuário".

**`src/products/concrete/ProdutoEletronico.ts`**
```typescript
import InterfaceProduto from "../interfaces/InterfaceProduto";

export default class ProdutoEletronico implements InterfaceProduto {
    public categoria: string = "Eletrônicos";
    constructor(
        public nome: string,
        public descricao: string,
        public preco: number
    ) {}

    exibirDetalhes(): void {
        console.log(`Eletrônico: ${this.nome} - R$${this.preco}`);
    }
}
```

**`src/products/concrete/ProdutoVestuario.ts`**
```typescript
import InterfaceProduto from "../interfaces/InterfaceProduto";

export default class ProdutoVestuario implements InterfaceProduto {
    public categoria: string = "Vestuário";
    constructor(
        public nome: string,
        public descricao: string,
        public preco: number
    ) {}

    public exibirDetalhes(): void {
        console.log(`Item de Vestuário: ${this.nome} (${this.categoria}) - R$${this.preco}`);
    }
}
```

**`src/products/concrete/acessorios/Garantia.ts`**
```typescript
import InterfaceAcessorio from "../../interfaces/InterfaceAcessorio";

export default class Garantia implements InterfaceAcessorio {
    nome: string = "Garantia Estendida";
    descricao: string = "Cobertura de 12 meses para defeitos de fabricação.";
}
```

**`src/products/concrete/acessorios/TabelaDeMedidas.ts`**
```typescript
import InterfaceAcessorio from "../../interfaces/InterfaceAcessorio";

export default class TabelaDeMedidas implements InterfaceAcessorio {
    public nome: string = "Tabela de Medidas";
    public descricao: string = "Guia de tamanhos padrão (P, M, G, GG) para este item.";
}
```

**`src/factories/concrete/EletronicoFactory.ts`**
```typescript
import InterfaceProdutoFactory from "../interfaces/InterfaceProdutoFactory";
import InterfaceProduto from "../../products/interfaces/InterfaceProduto";
import InterfaceAcessorio from "../../products/interfaces/InterfaceAcessorio";
import ProdutoEletronico from "../../products/concrete/ProdutoEletronico";
import Garantia from "../../products/concrete/acessorios/Garantia";

export default class EletronicoFactory implements InterfaceProdutoFactory {
    public criarProduto(nome: string, descricao: string, preco: number): InterfaceProduto {
        return new ProdutoEletronico(nome, descricao, preco);
    }

    public criarAcessorio(): InterfaceAcessorio {
        return new Garantia();
    }
}
```

**`src/factories/concrete/VestuarioFactory.ts`**
```typescript
import InterfaceProdutoFactory from "../interfaces/InterfaceProdutoFactory";
import InterfaceProduto from "../../products/interfaces/InterfaceProduto";
import InterfaceAcessorio from "../../products/interfaces/InterfaceAcessorio";
import ProdutoVestuario from "../../products/concrete/ProdutoVestuario";
import TabelaDeMedidas from "../../products/concrete/acessorios/TabelaDeMedidas";

export default class VestuarioFactory implements InterfaceProdutoFactory {
    public criarProduto(nome: string, descricao: string, preco: number): InterfaceProduto {
        return new ProdutoVestuario(nome, descricao, preco);
    }

    public criarAcessorio(): InterfaceAcessorio {
        return new TabelaDeMedidas();
    }
}
```

**Explicação:** Cada fábrica concreta é especializada em criar uma família de produtos relacionados: `EletronicoFactory` produz `ProdutoEletronico` e `Garantia`, enquanto `VestuarioFactory` produz `ProdutoVestuario` e `TabelaDeMedidas`. Essa especialização assegura que os produtos gerados por uma mesma fábrica sejam sempre compatíveis entre si.

---
#### **4.2.4. Camada de Serviço (`Client`)**
A classe `ProdutoService` atua como o cliente do padrão. Ela utiliza a fábrica para criar produtos com base nos dados de uma requisição HTTP.

**`src/services/ProdutoService.ts`**
```typescript
import { Router, Request, Response } from "express";
import InterfaceProdutoFactory from "../factories/interfaces/InterfaceProdutoFactory";
import EletronicoFactory from "../factories/concrete/EletronicoFactory";
import VestuarioFactory from "../factories/concrete/VestuarioFactory";

const router = Router();

export default class ProdutoService {
    public router: Router;

    constructor() {
        this.router = router;
        this.configurarRotas();
    }

    private configurarRotas(): void {
        this.router.post("/produto", (req: Request, res: Response) => {
            try {
                const { nome, descricao, preco, categoria } = req.body;

                let factory: InterfaceProdutoFactory;

                // Seleciona a fábrica com base na categoria
                if (categoria === "Eletrônicos") {
                    factory = new EletronicoFactory();
                } else if (categoria === "Vestuário") {
                    factory = new VestuarioFactory();
                } else {
                    return res.status(400).send({ error: "Categoria de produto inválida ou não suportada." });
                }

                // Usa a fábrica para criar a família de produtos
                const produto = factory.criarProduto(nome, descricao, preco);
                const acessorio = factory.criarAcessorio();

                res.status(201).send({ produto, acessorio });

            } catch (error) {
                res.status(500).send({ error: "Erro interno no servidor." });
            }
        });
    }
}
```
**Explicação:** O `ProdutoService` recebe uma requisição, determina qual fábrica concreta utilizar com base no campo `categoria`, e orquestra a criação da família de produtos. O cliente está completamente desacoplado das classes concretas dos produtos.

## **5. Como Executar a Implementação**

### **5.1. Pré-requisitos**
* Node.js (versão 16 ou superior)
* npm (gerenciador de pacotes do Node.js)
* Postman (ou similar) para testar os endpoints.

### **5.2. Passos para Execução**
**Passo 1:** Navegue até o diretório do projeto.

**Passo 2:** Instale as dependências.
```bash
npm install
```

**Passo 3:** Execute o servidor.
```bash
npm start
```

### **5.3. Testando a API com o Postman**

#### **Criação de Produto da Família "Eletrônicos"**
* **Método**: `POST`
* **URL**: `http://localhost:3001/produto`
* **Headers**: `Content-Type: application/json`
* **Body (JSON)**:
    ```json
    {
        "nome": "Smartphone Galaxy S30",
        "descricao": "Celular de última geração com 256GB.",
        "preco": 4500.00,
        "categoria": "Eletrônicos"
    }
    ```
* **Resposta Esperada (201 Created)**:
    ```json
    {
        "produto": {
            "categoria": "Eletrônicos",
            "nome": "Smartphone Galaxy S30",
            "descricao": "Celular de última geração com 256GB.",
            "preco": 4500
        },
        "acessorio": {
            "nome": "Garantia Estendida",
            "descricao": "Cobertura de 12 meses para defeitos de fabricação."
        }
    }
    ```

## **6. Senso Crítico e Trabalho em Equipe**

A implementação do padrão **Abstract Factory** no projeto "AquiTemFCTE" mostrou o processo prático de **senso crítico** e a importância do **trabalho em equipe** no desenvolvimento de software.

Criticamente, a equipe avaliou o domínio do problema, reconhecendo a necessidade de gerenciar famílias de produtos relacionadas (como `ProdutoEletronico` e `Garantia`, ou `ProdutoVestuario` e `TabelaDeMedidas`), o que levou à escolha estratégica do Abstract Factory para garantir o desacoplamento e a conformidade com os princípios SOLID. Esse processo de análise detalhada e modelagem da solução, conforme descrito na metodologia, demonstra uma abordagem ponderada para projetar uma arquitetura escalável e de fácil manutenção.

A participação em equipe, por sua vez, foi fundamental para orquestrar as diversas etapas, desde a análise inicial e a definição das interfaces abstratas, até a implementação das fábricas e produtos concretos em TypeScript, conforme evidenciado pelo histórico de versões e pela distribuição de responsabilidades. A padronização proporcionada pelo Abstract Factory facilitou a colaboração, permitindo que os desenvolvedores contribuíssem com partes distintas do sistema, mantendo a consistência e a compatibilidade entre os componentes, garantindo assim a coesão do projeto.

## **7. Conclusão**

A implementação do padrão **Abstract Factory** no projeto "AquiTemFCTE" demonstrou ser uma abordagem eficaz para gerenciar a criação de famílias de objetos complexos e relacionados. O Abstract Factory se destaca ao garantir a consistência entre múltiplos objetos que precisam ser criados juntos.

A solução permitiu isolar completamente o código cliente das classes concretas, facilitando a adição de novas famílias de produtos no futuro sem a necessidade de alterar o código cliente existente, o que reforça a manutenibilidade e escalabilidade do software.

## **Referências**

> SERRANO, Milene, Arquitetura e Desenho de Software - Aula - GOFS CRIACIONAIS. Disponível em: https://aprender3.unb.br/pluginfile.php/3178542/mod_page/content/1/Arquitetura%20e%20Desenho%20de%20Software%20-%20Aula%20GoFs%20Criacionais%20-%20Profa.%20Milene.pdf. Universidade de Brasília - UnB. Brasília. Acesso em 13 de outubro de 2025.

## Histórico de Versões
| Versão | Data | Descrição | Autor(es) | Revisor(es) | Detalhes da Revisão |
| -- | -- | -- | -- | -- | -- |
| 1.0 | 13/10/2025 | Desenvolvimento inicial do documento com Introdução | [Davi Camilo](https://github.com/Davicamilo23) | [Lucas Guimarães](https://github.com/lcsgborges) | Sem erros |
| 1.1 | 15/10/2025 | Adição dos códigos e documentação | [Caio Sabino](https://github.com/caiomsabino) | [Davi Camilo](https://github.com/Davicamilo23) | Sem erros |
| 1.2 | 15/10/2025 | Adição de códigos e tópicos faltantes e referência | [Davi Camilo](https://github.com/Davicamilo23) | [Caio Sabino](https://github.com/caiomsabino) | Trocar nome das classes de interface.  |
| 1.3 | 16/10/2025 | Adição do vídeo de execução do código e correção de nomenclatura de códigos. | [Caio Sabino](https://github.com/caiomsabino) | [Davi Camilo](https://github.com/Davicamilo23) | Corrigir nomes de classes repetidos erroneamente. |
| 1.4 | 16/10/2025 | Adição do Diagrama do Abstract Factory e do Senso Crítico e Trabalho em Equipe | [Davi Camilo](https://github.com/Davicamilo23) | [Caio Sabino](https://github.com/caiomsabino) | Sem erros |
| 1.5 | 16/10/2025 | Correção da numeração do artefato | [Davi Camilo](https://github.com/Davicamilo23) | [Caio Sabino](https://github.com/caiomsabino) | Sem erros |