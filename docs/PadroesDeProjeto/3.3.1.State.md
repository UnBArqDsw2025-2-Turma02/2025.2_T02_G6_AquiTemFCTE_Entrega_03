## 1. Introdução

O padrão de projeto **State** pertence ao grupo dos **padrões comportamentais** (_Behavioral Patterns_) propostos pela _Gang of Four (GoF)_.  
Seu propósito é **permitir que um objeto altere seu comportamento quando seu estado interno muda**, dando a impressão de que o objeto muda de classe (GAMMA et al., 1995; [Refactoring.Guru, 2025](https://refactoring.guru/pt-br/design-patterns/state)).

Os padrões comportamentais auxiliam no **controle das interações e variações de comportamento entre objetos**, permitindo a troca de algoritmos ou comportamentos dinamicamente conforme o contexto.  
No caso do **State**, ele organiza o comportamento dependente de estado em **classes separadas**, facilitando a **extensão** e **manutenção** do código.

No contexto do **AquiTemFCTE**, esse padrão é aplicado para gerenciar os **estados de um produto** dentro da plataforma — por exemplo, **Disponível**, **Reservado** ou **Vendido** —, alterando o comportamento do sistema em relação ao produto conforme seu estado.

---

## 2. Metodologia Adotada

A documentação e a modelagem do padrão **State** para o projeto **AquiTemFCTE** seguiram três etapas principais:

1. **Revisão teórica** dos conceitos de máquinas de estado finitas e do padrão State com base em Gamma et al. (1995) e no material da professora Milene Serrano (2025);
2. **Análise contextual** da aplicação no ciclo de vida dos produtos dentro do sistema AquiTemFCTE;
3. **Modelagem UML** e implementação prática inspirada nas boas práticas descritas em [Refactoring.Guru (2025)](https://refactoring.guru/pt-br/design-patterns/state).

---

## 3. Exposição e Explicação da Modelagem

### 3.1. Contexto no AquiTemFCTE

No **AquiTemFCTE**, os produtos passam por um **ciclo de vida controlado** que reflete seu estado de negociação na plataforma:

- **Disponível** → Produto publicado e visível aos usuários;
- **Reservado** → Produto em negociação, aguardando confirmação;
- **Vendido** → Produto finalizado e removido das listagens.

A cada transição, o comportamento do sistema muda: apenas produtos disponíveis podem ser reservados, e apenas produtos reservados podem ser vendidos.

O padrão **State** é a solução ideal para modelar esse comportamento, pois encapsula cada estado em uma classe própria e permite que o objeto `Produto` altere dinamicamente suas ações de acordo com seu estado atual, sem depender de condicionais.

### 3.2. Mapeamento dos Papéis (GoF → AquiTemFCTE)

| Papel GoF         | Implementação no AquiTemFCTE         |
| ----------------- | ------------------------------------ |
| **Context**       | `Produto`                            |
| **State**         | `EstadoProduto` (interface)          |
| **ConcreteState** | `Disponivel`, `Reservado`, `Vendido` |

O **Contexto (`Produto`)** armazena uma referência para o estado atual e **delegará o comportamento** a este estado.  
Cada **ConcreteState** define suas **ações válidas** e as **transições permitidas**.

### 3.3. Decisões de Design

- Transições de estado são controladas por **composição**, não por condicionais;
- Cada estado concreto define **ações válidas** e impede transições inválidas;
- O `Produto` apenas **encaminha chamadas** ao seu estado atual (`self.estado.vender()`, por exemplo);
- Isso melhora a **coerência**, evita duplicação de lógica e facilita a **evolução** do sistema.

---

## 4. Exposição e Explicação da Implementação

A implementação proposta em **Python** demonstra o padrão **State** no contexto do ciclo de vida de um produto.  
Ela segue a estrutura sugerida por [Refactoring.Guru](https://refactoring.guru/pt-br/design-patterns/state), adaptada à modelagem do **AquiTemFCTE**.

### 4.1. Estrutura de Classes

- **`Produto`**: Contexto, armazena o estado atual e delega as ações.
- **`EstadoProduto`**: Interface que define os métodos possíveis (`reservar()`, `vender()`, `cancelar()`).
- **`Disponivel`, `Reservado`, `Vendido`**: Estados concretos com comportamentos e transições específicas.

### 4.2. Exemplo Simplificado

```python
produto = Produto("Calculadora Científica", 90.0)
produto.reservar()   # Transição para Reservado
produto.vender()     # Transição para Vendido
produto.cancelar()   # Inválido: produto já vendido
```

### 4.3. Diagrama de Classes

<p align="center" style="font-size: 12;"><b>Figura 1:</b> Diagrama de Classes - Padrão State</p>

<div align="center">

![State](../assets/state-classes.png)

</div>

<p align="center" style="font-size: 12;"><small><b>Fonte:</b> Algusto Caldas e Eric Rabelo</small></p>

---

## 5. Aplicação Didática (Miniaplicação)

Foi desenvolvida uma **miniaplicação em Python** (`state_aquitemfcte.py`) que demonstra o uso do padrão State no **AquiTemFCTE**.  
Ela permite alterar o estado de produtos e visualizar as ações válidas em cada situação.

**Execução:**

```bash
python state_aquitemfcte.py
```

**Funcionalidades:**

- Transições de estado válidas e inválidas;
- Exibição das ações disponíveis em cada estado;
- Mensagens dinâmicas conforme o estado do produto.

---

## 6. Senso Crítico e Trabalho em Equipe

O desenvolvimento desse módulo reforçou os benefícios do padrão **State** descritos por [Refactoring.Guru](https://refactoring.guru/pt-br/design-patterns/state) e **Milene Serrano (2025)**:  
ele melhora a **coerência do código**, elimina **condicionais extensos** e facilita a **extensão com novos estados**.

O trabalho colaborativo permitiu dividir responsabilidades de maneira modular (cada integrante modelando um estado concreto ou o contexto principal), consolidando o aprendizado sobre encapsulamento e delegação.

---

## 7. Conclusão

A aplicação do padrão **State** no sistema **AquiTemFCTE** demonstrou de forma prática como o comportamento de um objeto pode **mudar dinamicamente** com base em seu estado interno, sem recorrer a blocos condicionais.

O padrão contribui diretamente para a **clareza, manutenção e extensibilidade** do código, tornando-o alinhado aos princípios da **Programação Orientada a Objetos** e às boas práticas ensinadas na disciplina de **Arquitetura e Desenho de Software (UnB, 2025)**.

---

## 8. Bibliografia

- GAMMA, Erich et al. _Design Patterns: Elements of Reusable Object-Oriented Software._ Addison-Wesley, 1995.
- FREEMAN, Eric; FREEMAN, Elisabeth. _Head First Design Patterns._ O'Reilly Media, 2004.
- LARMAN, Craig. _Applying UML and Patterns._ 3rd ed. Prentice Hall, 2004.
- [REFACTORING.GURU. “Padrão State”](https://refactoring.guru/pt-br/design-patterns/state). Acesso em: 23 out. 2025.
- [SERRANO, Milene. “Arquitetura e Desenho de Software - Aula GoFs Comportamentais - UnB”](https://aprender3.unb.br/pluginfile.php/3178544/mod_page/content/1/Arquitetura%20e%20Desenho%20de%20Software%20-%20Aula%20GoFs%20Estruturais%20-%20Profa.%20Milene.pdf). Acesso em: 23 out. 2025.

---

## Histórico de Versões

| Versão | Data       | Descrição                                             | Autor(es)                                       | Revisor(es)                                     | Detalhes da revisão |
| :----- | :--------- | :---------------------------------------------------- | :---------------------------------------------- | :---------------------------------------------- | :------------------ |
| 1.0    | 23/10/2025 | Criação inicial do documento State                    | [Eric Rabelo](https://github.com/rabelzx)       | [Algusto Caldas](https://github.com/Algusto-RC) | Revisado e Aprovado |
| 2.0    | 23/10/2025 | Reformulação com referências oficiais (Guru e Milene) | [Algusto Caldas](https://github.com/Algusto-RC) | [Eric Rabelo](https://github.com/rabelzx)       | Revisado e Aprovado |
