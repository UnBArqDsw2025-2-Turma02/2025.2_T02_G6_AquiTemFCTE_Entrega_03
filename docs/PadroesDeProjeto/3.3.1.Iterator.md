# 3.3.x. Iterator

## 1. Padrão GOF Iterator

O padrão de projeto Iterator é um padrão comportamental que fornece uma maneira de acessar sequencialmente os elementos de uma coleção sem expor sua representação interna. A intenção principal do Iterator é desacoplar a lógica de iteração da estrutura de dados subjacente, permitindo percorrer diferentes tipos de coleções de forma uniforme (GAMMA et al., 1994). Este padrão é particularmente útil quando se deseja navegar por uma coleção de objetos sem conhecer sua estrutura interna, oferecendo uma interface comum para diferentes tipos de agregações.

A utilização do padrão Iterator promove maior flexibilidade e manutenibilidade no código. Ele permite que a lógica de iteração seja independente da estrutura de dados, facilitando a troca de implementações de coleções sem afetar o código cliente. Esta abordagem está em conformidade com o princípio da responsabilidade única (Single Responsibility Principle) do SOLID, uma vez que separa a lógica de iteração da lógica de armazenamento de dados. Além disso, o padrão permite múltiplas iterações simultâneas sobre a mesma coleção, respeitando o princípio aberto/fechado e aumentando a reutilização e flexibilidade do software.

## 2. Metodologia

A metodologia para a aplicação do padrão de projeto Iterator neste trabalho foi dividida em quatro etapas principais, partindo da análise e culminando na implementação e teste.

1. O primeiro passo consistiu na análise do [diagrama de classes](https://unbarqdsw2025-2-turma02.github.io/2025.2_T02_G6_AquiTemFCTE_Entrega_02/#/Modelagem/2.1.2.DiagramaClasses) do projeto "AquiTemFCTE". A partir dessa análise, identificou-se a necessidade de implementar um sistema de iteração sobre o catálogo de produtos da plataforma. A justificativa para essa escolha reside na importância de fornecer uma maneira uniforme e eficiente de percorrer coleções de produtos sem expor a estrutura interna do catálogo. O padrão Iterator é perfeitamente adequado para essa finalidade, permitindo navegar pelos produtos de forma sequencial e controlada, sem que o código cliente precise conhecer como os produtos são armazenados internamente.

2. Após a identificação da necessidade, o segundo passo foi a modelagem da solução utilizando o padrão GOF Iterator. Para essa finalidade, foi utilizada a plataforma online [Draw.io](https://app.diagrams.net/), que permitiu a criação do diagrama de classes (conforme apresentado na Figura 1) no padrão Iterator. Essa modelagem visual foi importante para definir a estrutura das interfaces (Iterator e Aggregate), as implementações concretas (CatalogoIterator e CatalogoFCTE) e o modelo Produto antes de iniciar a codificação.

3. O terceiro passo envolveu a seleção das tecnologias para a futura implementação e teste da modelagem. Optou-se por utilizar `TypeScript` em conjunto com `Node.js`. A escolha pelo TypeScript se deu por ser uma linguagem fortemente tipada e orientada a objetos, o que a torna mais robusta para a implementação de padrões de projeto em comparação ao JavaScript puro. O Node.js foi utilizado para executar o código TypeScript e simular o comportamento de navegação no catálogo de produtos.

4. Finalmente, a quarta e última etapa foi a implementação efetiva do código, seguindo o que foi planejado na modelagem, e a realização de testes para validar o funcionamento do padrão. Essa fase garantiu que o sistema de iteração funcionasse corretamente, permitindo percorrer todos os produtos do catálogo de forma sequencial e controlada.

## 4. Participantes

Os participantes da implementação deste Padrão de Projeto estão descritos na tabela abaixo:

<p style="text-align: center;">Tabela 1: Participantes da implementação do Iterator</p>

|Matrícula | Aluno |
| -- | -- |
| 21/1061583  |  Daniel Rodrigues  |
| 21/1061897  |  Igor Justino      |

## 4. Modelagem do Iterator

<p align="center" style="font-size: 12;">
Figura 1: Diagrama de Classes - Padrão Iterator
</p>

![Iterator](/../assets/Iterator.png)

<p align="center" style="font-size: 12;">
Fonte: Daniel Rodrigues
</p>

## 5. Informações Técnicas e Implementação

### 5.1. Tecnologias Utilizadas

A implementação do padrão GOF Iterator foi desenvolvida utilizando as seguintes tecnologias:

- **TypeScript (v5.0.0)**: Linguagem principal escolhida por ser fortemente tipada e orientada a objetos, oferecendo maior robustez na implementação de padrões de projeto
- **Node.js**: Runtime JavaScript para execução do código
- **ts-node (v10.9.0)**: Ferramenta para execução direta de arquivos TypeScript
- **@types/node (v20.0.0)**: Definições de tipos do Node.js para TypeScript

### 5.2. Estrutura da Implementação

A implementação seguiu fielmente a estrutura do padrão Iterator, organizando o código nas seguintes classes e interfaces:

#### 5.2.1. Classe Produto

Esta classe representa o modelo de dados de um produto no catálogo:

```typescript
export class Produto {
    private nome: string;
    private descricao: string;
    private preco: number;
    private modalidade: string;
    private imagem: string[];
    private estado: boolean;

    constructor(nome: string, descricao: string) {
        this.nome = nome;
        this.descricao = descricao;
        this.preco = 0;
        this.modalidade = "";
        this.imagem = [];
        this.estado = false;
    }

    public setNome(nome: string): void {
        this.nome = nome;
    }

    public setDescricao(descricao: string): void {
        this.descricao = descricao;
    }

    public setModalidade(modalidade: string): void {
        this.modalidade = modalidade;
    }

    public setPreco(preco: number): void {
        this.preco = preco;
    }

    public setImagem(imagem: string[]): void {
        this.imagem = imagem;
    }

    public setEstado(estado: boolean): void {
        this.estado = estado;
    }

    public getDados(): void {
        console.log(`Produto: ${this.nome}`);
        console.log(`Descrição: ${this.descricao}`);
        console.log(`Preço: ${this.preco}`);
        console.log(`Modalidade: ${this.modalidade}`);
        console.log(`Imagens: ${this.imagem.join(', ')}`);
        console.log(`Estado: ${this.estado ? 'Ativo' : 'Inativo'}`);
    }

    public getNome(): string {
        return this.nome;
    }

    public getDescricao(): string {
        return this.descricao;
    }

    public getPreco(): number {
        return this.preco;
    }

    public getModalidade(): string {
        return this.modalidade;
    }

    public getImagem(): string[] {
        return this.imagem;
    }

    public getEstado(): boolean {
        return this.estado;
    }
}
```

**Explicação**: A classe `Produto` é o elemento individual da coleção que será iterada. Ela encapsula os atributos e comportamentos de um produto no marketplace universitário, incluindo nome, descrição, preço, modalidade (venda ou troca), imagens e estado. A classe fornece métodos getters e setters para acesso controlado aos atributos, além do método `getDados()` para exibir informações completas do produto.

#### 5.2.2. Interface ProdutoIterator

Interface que define o contrato do Iterator:

```typescript
import { Produto } from "../models/Produto";

export interface ProdutoIterator {
    hasNext(): boolean;
    next(): Produto;
}
```

**Explicação**: A interface `ProdutoIterator` define o contrato do padrão Iterator. Ela estabelece dois métodos fundamentais: `hasNext()` que verifica se ainda existem elementos a serem percorridos, e `next()` que retorna o próximo elemento da coleção. Esta interface permite que diferentes implementações de iteradores sejam usadas de forma intercambiável.

#### 5.2.3. Interface ColecaoProdutos

Interface que define o contrato do Aggregate:

```typescript
import { ProdutoIterator } from "./ProdutoIterator";

export interface ColecaoProdutos {
    criarIterator(): ProdutoIterator;
}
```

**Explicação**: A interface `ColecaoProdutos` representa o Aggregate no padrão Iterator. Ela define o método `criarIterator()` que é responsável por criar e retornar uma instância do iterator apropriado para percorrer a coleção. Esta interface garante que qualquer coleção de produtos possa fornecer um iterator para navegação.

#### 5.2.4. Classe CatalogoIterator (Concrete Iterator)

Classe que implementa a lógica de iteração sobre os produtos:

```typescript
import { ProdutoIterator } from "../interfaces/ProdutoIterator";
import { Produto } from "../models/Produto";

export class CatalogoIterator implements ProdutoIterator {
    private produtos: Produto[];
    private posicao: number;

    constructor(produtos: Produto[]) {
        this.produtos = produtos;
        this.posicao = 0;
    }

    public hasNext(): boolean {
        return this.posicao < this.produtos.length;
    }

    public next(): Produto {
        if (!this.hasNext()) {
            throw new Error("Não há mais produtos no catálogo");
        }
        return this.produtos[this.posicao++];
    }
}
```

**Explicação**: A classe `CatalogoIterator` é a implementação concreta do Iterator. Ela mantém uma referência à lista de produtos e controla a posição atual da iteração através do atributo `posicao`. O método `hasNext()` verifica se a posição atual é menor que o tamanho da coleção, enquanto `next()` retorna o produto na posição atual e incrementa o contador. Se não houver mais elementos, `next()` lança uma exceção informativa.

#### 5.2.5. Classe CatalogoFCTE (Concrete Aggregate)

Classe que mantém a coleção de produtos e cria iterators:

```typescript
import { ColecaoProdutos } from "../interfaces/ColecaoProdutos";
import { ProdutoIterator } from "../interfaces/ProdutoIterator";
import { CatalogoIterator } from "../iterators/CatalogoIterator";
import { Produto } from "../models/Produto";

export class CatalogoFCTE implements ColecaoProdutos {
    private produtos: Produto[];

    constructor() {
        this.produtos = [];
    }

    public adicionarProduto(produto: Produto): void {
        this.produtos.push(produto);
    }

    public criarIterator(): ProdutoIterator {
        return new CatalogoIterator(this.produtos);
    }
}
```

**Explicação**: A classe `CatalogoFCTE` representa o Aggregate concreto, mantendo a coleção de produtos internamente. Ela fornece o método `adicionarProduto()` para inserir novos produtos no catálogo e implementa `criarIterator()` que instancia e retorna um `CatalogoIterator` configurado com a lista de produtos. Esta classe encapsula completamente a estrutura interna da coleção, expondo apenas a interface de iteração.

#### 5.2.6. Código de Demonstração (index.ts)

Código cliente que demonstra o uso do padrão Iterator:

```typescript
import { CatalogoFCTE } from "./collections/CatalogoFCTE";
import { Produto } from "./models/Produto";

const catalogo = new CatalogoFCTE();

const produto1 = new Produto("Notebook Dell", "Notebook em bom estado");
produto1.setPreco(2500);
produto1.setModalidade("Venda");
produto1.setImagem(["notebook1.jpg", "notebook2.jpg"]);
produto1.setEstado(true);

const produto2 = new Produto("iPhone 12", "iPhone seminovo");
produto2.setPreco(3000);
produto2.setModalidade("Venda");
produto2.setImagem(["iphone1.jpg"]);
produto2.setEstado(true);

const produto3 = new Produto("Livro de Cálculo", "Livro para troca");
produto3.setPreco(0);
produto3.setModalidade("Troca");
produto3.setImagem(["livro1.jpg"]);
produto3.setEstado(true);

catalogo.adicionarProduto(produto1);
catalogo.adicionarProduto(produto2);
catalogo.adicionarProduto(produto3);

const iterator = catalogo.criarIterator();

console.log("=== Iterando sobre o catálogo de produtos ===\n");

while (iterator.hasNext()) {
    const produto = iterator.next();
    produto.getDados();
    console.log("---");
}
```

**Explicação**: O código de demonstração cria um catálogo de produtos e adiciona três itens diferentes: um notebook para venda, um iPhone para venda e um livro para troca. Após popular o catálogo, o código obtém um iterator através do método `criarIterator()` e utiliza um loop `while` com `hasNext()` para verificar se há mais elementos e `next()` para obter cada produto sequencialmente. O código cliente não precisa conhecer a estrutura interna do catálogo, apenas utiliza a interface do iterator para navegar pelos produtos de forma uniforme e controlada.

## 6. Como executar a Implementação

Para executar a implementação do padrão Iterator desenvolvida, siga os seguintes passos:

### 6.1. Pré-requisitos

- **Node.js** (versão 16 ou superior)
- **npm** (gerenciador de pacotes do Node.js)

### 6.2. Passos para Execução

#### Passo 1: Navegue até o diretório do projeto

```bash
cd GOFs/Comportamental/Iterator
```

#### Passo 2: Instale as dependências

```bash
npm install
```

#### Passo 3: Execute a aplicação

```bash
npm run dev
```

### 6.3. Saída Esperada

Ao executar o comando `npm run dev`, você verá a seguinte saída no terminal demonstrando a iteração sobre o catálogo:

```
=== Iterando sobre o catálogo de produtos ===

Produto: Notebook Dell
Descrição: Notebook em bom estado
Preço: 2500
Modalidade: Venda
Imagens: notebook1.jpg, notebook2.jpg
Estado: Ativo
---
Produto: iPhone 12
Descrição: iPhone seminovo
Preço: 3000
Modalidade: Venda
Imagens: iphone1.jpg
Estado: Ativo
---
Produto: Livro de Cálculo
Descrição: Livro para troca
Preço: 0
Modalidade: Troca
Imagens: livro1.jpg
Estado: Ativo
---
```

### 6.4. Scripts Disponíveis

- `npm run dev`: Executa a aplicação usando ts-node
- `npm run build`: Compila o código TypeScript para JavaScript (pasta dist/)
- `npm start`: Executa a aplicação compilada

## 7. Vídeo de Execução do Código e Local do Código

### Vídeo de Execução:

<iframe width="560" height="315" src="https://www.youtube.com/embed/-2N_3SawFnM?si=LaBsJKPqvmXcVmOO" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>

### Local do Iterator no Repositório

[Clique aqui para acessar o código no repositório](https://github.com/UnBArqDsw2025-2-Turma02/2025.2_T02_G6_AquiTemFCTE_Entrega_03/tree/main/GOFs/Comportamental/Iterator)

## 8. Senso Crítico e Trabalho em Equipe

### Justificativas e Senso Crítico

A aplicação do padrão GOF Iterator no contexto do projeto "AquiTemFCTE" demonstrou ser uma decisão arquitetural acertada para o gerenciamento e navegação do catálogo de produtos da plataforma. Em sistemas de marketplace onde coleções de produtos precisam ser percorridas frequentemente para exibição, filtragem e processamento, ter uma interface uniforme de iteração é fundamental para manter o código limpo e desacoplado da estrutura de dados subjacente.

O Iterator implementado resolve três desafios importantes de forma elegante: (1) encapsula a estrutura interna do catálogo, permitindo mudanças na implementação sem afetar o código cliente; (2) fornece uma interface uniforme de navegação independente de como os produtos são armazenados; (3) permite múltiplas iterações simultâneas sobre a mesma coleção sem interferência. Esta implementação garante flexibilidade para futuras mudanças na estrutura de armazenamento, como migrar de arrays para outras estruturas de dados mais eficientes.

A arquitetura escolhida está em conformidade com os princípios SOLID. O Single Responsibility Principle (SRP) é respeitado ao separar a lógica de iteração da lógica de armazenamento de dados. O Open/Closed Principle (OCP) permite adicionar novos tipos de iteradores (como iteradores filtrados, ordenados ou reversos) sem modificar o catálogo ou o código cliente. Esta separação também facilita testes unitários, permitindo testar a lógica de iteração independentemente da coleção.

### Comentários sobre o Trabalho em Equipe

O desenvolvimento do padrão Iterator foi realizado de forma individual, com foco na análise dos requisitos de navegação do catálogo e na implementação de uma solução elegante e extensível. O trabalho iniciou com o estudo do diagrama de classes do projeto para identificar onde o padrão seria mais útil, seguido pela modelagem visual utilizando Draw.io para garantir que a estrutura seguisse fielmente o padrão GoF.

Durante a implementação, houve atenção especial para manter o código limpo, sem comentários, e seguindo as melhores práticas de TypeScript com tipagem forte. A estrutura de pastas foi organizada de forma lógica, separando interfaces, modelos, iteradores e coleções em diretórios distintos. Os testes de execução confirmaram que o padrão funciona corretamente, permitindo iteração sequencial sobre produtos sem expor a estrutura interna do catálogo.

## 9. Conclusão

A implementação do padrão Iterator no sistema de catálogo de produtos do AquiTemFCTE demonstra como esse padrão comportamental pode fornecer uma solução elegante para navegação em coleções, mantendo o encapsulamento e a flexibilidade arquitetural. O sistema desenvolvido permite percorrer produtos de forma sequencial e controlada, sem que o código cliente precise conhecer ou depender da estrutura interna do catálogo.

A arquitetura baseada no padrão Iterator proporcionou uma separação clara entre a lógica de iteração e a lógica de armazenamento de dados. Esta separação facilita futuras expansões, como a implementação de iteradores especializados (filtrados por modalidade, ordenados por preço, iteração reversa) ou a mudança da estrutura de dados subjacente sem impactar o código cliente. A conformidade com os princípios SOLID garante que o código seja facilmente testável, extensível e manutenível.

O padrão Iterator se mostrou especialmente adequado para este cenário, pois fornece uma interface uniforme de navegação que pode ser utilizada independentemente de como os produtos são armazenados internamente. Esta implementação estabelece uma base sólida para outras funcionalidades do AquiTemFCTE que necessitem percorrer coleções, como exibição de produtos em diferentes formatos, aplicação de filtros ou geração de relatórios.

## 10. Referências

> REFATORING.GURU. Padrão Iterator. Disponível em: https://refactoring.guru/pt-br/design-patterns/iterator. Acesso em: 23 outubro. 2025.

> TUTORIALSPOINT. Python Design Patterns - Iterator. Disponível em: https://www.tutorialspoint.com/design_pattern/iterator_pattern.html. Acesso em: 23 outubro. 2025.

## Histórico de Versões

| Versão | Data       | Descrição                                | Autor(es)                                      | Revisor(es) | Detalhes da Revisão |
| ------ | ---------- | ---------------------------------------- | ---------------------------------------------- | ----------- | ------------------- |
| 1.0    | 23/10/2025 | Criação do Arquivo e inserção do conteúdo | [Igor Justino](https://github.com/IgorJustino) | [Daniel Rodrigues](https://github.com/DanielRogs) | Falta seção dos participantes |
| 1.1    | 23/10/2025 | Correção dos numeros dos tópicos e insercao dos participantes | [Daniel Rodrigues](https://github.com/DanielRogs) | [Igor Justino](https://github.com/IgorJustino) | Falta vídeo de apresentação |
| 1.2    | 23/10/2025 | Inserção do vídeo de apresentação do GOF Iterator             | [Daniel Rodrigues](https://github.com/DanielRogs) | [Igor Justino](https://github.com/IgorJustino) | Sem erros identificado |