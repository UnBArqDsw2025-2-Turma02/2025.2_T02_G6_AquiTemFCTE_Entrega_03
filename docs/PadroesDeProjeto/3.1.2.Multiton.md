# 3.1.2. **Multiton**

## Introdução

Este documento apresenta uma **demonstração acadêmica** do padrão de projeto **Multiton**, um padrão criacional do grupo **GoF** (Gang of Four). 

O padrão **Multiton** é uma extensão do padrão **Singleton** que, em vez de garantir uma única instância global, assegura que haja **uma única instância para cada chave específica**. Isso é ideal para cenários onde diferentes partes do sistema precisam de instâncias controladas, como em **sistemas escalados** e **microsserviços** (BLACKWASP, 2025).

Para ilustrar seu uso, este documento explora um **protótipo de microsserviço** que utiliza o Multiton para gerenciar diferentes tipos de recursos de forma independente e segura.

---

## Metodologia e Desenvolvimento

Para fins **educacionais**, foi desenvolvido um **protótipo de microsserviço** em **Python** que simula o gerenciamento de recursos. A implementação segue os princípios da **Programação Orientada a Objetos (POO)** e as diretrizes de padrões criacionais.

Este protótipo demonstra como o padrão Multiton pode centralizar a lógica de gerenciamento de recursos, como conexões de banco de dados (`DatabaseConnection`) ou caches (`CacheManager`), garantindo que haja apenas uma instância para cada tipo de recurso. Essa abordagem é valiosa em **arquiteturas distribuídas** e de **microsserviços**, onde a gestão eficiente e a independência entre componentes são cruciais.

---

## Estrutura do Protótipo (Exemplo Acadêmico)

O código abaixo ilustra a aplicação do padrão Multiton, servindo como uma demonstração conceitual:

  * **`ResourceManagerMultiton`**: A classe principal que garante uma única instância para cada tipo de recurso, como `"DatabaseConnection"` ou `"CacheManager"`, usando a chave `resource_type`.
  * **`Resource`**: Uma classe que representa um recurso específico, como um banco de dados ou cache, gerenciado por uma instância do Multiton.

```python
# PROTÓTIPO 
class ResourceManagerMultiton:
    _resource_managers = {}

    def __new__(cls, resource_type):
        if resource_type not in cls._resource_managers:
            instance = super().__new__(cls)
            instance.resource_type = resource_type
            instance.resources = []
            instance.config = {}
            cls._resource_managers[resource_type] = instance
        return cls._resource_managers[resource_type]

    def add_resource(self, resource):
        self.resources.append(resource)

    def get_resources(self):
        return self.resources

    def set_config(self, key, value):
        self.config[key] = value

    def get_config(self, key):
        return self.config.get(key)

class Resource:
    def __init__(self, name, config_data):
        self.name = name
        self.config_data = config_data
        self.status = "active"

# Exemplo de uso em um microsserviço
db_manager = ResourceManagerMultiton("DatabaseConnection")
db_manager.set_config("host", "localhost")
db_manager.set_config("port", 5432)
db_manager.add_resource(Resource("UserDB", {"schema": "users", "pool_size": 10}))
db_manager.add_resource(Resource("ProductDB", {"schema": "products", "pool_size": 5}))

cache_manager = ResourceManagerMultiton("CacheManager")
cache_manager.set_config("type", "Redis")
cache_manager.set_config("ttl", 3600)
cache_resource = Resource("UserCache", {"size": "1GB", "strategy": "LRU"})
cache_manager.add_resource(cache_resource)

db_manager2 = ResourceManagerMultiton("DatabaseConnection")
print(db_manager is db_manager2)  # Saída: True
```

A saída `True` demonstra que `db_manager` e `db_manager2` são a **mesma instância**, pois foram criadas com a mesma chave (`"DatabaseConnection"`).

---

## Diagramas do Protótipo

### Diagrama de Classes

O diagrama abaixo ilustra a estrutura das classes do padrão Multiton e suas relações:

<p align="center" style="font-size: 12;"><b>Figura 1:</b> Diagrama de Classe</p>

![Diagrama_de_Classes](../Assets/multiton-classes.png) 

<p align="center" style="font-size: 12;"><small><b>Fonte:</b> Algusto Caldas e Eric Rabelo</small></p>

---

### Diagrama de Sequência - Criação de Instâncias

Este diagrama mostra o fluxo de criação e reutilização de instâncias do Multiton:

<p align="center" style="font-size: 12;"><b>Figura 2:</b> Diagrama de Sequência</p>

![Diagrama_de_Sequencia](../Assets/multiton-sequencia.png) 

<p align="center" style="font-size: 12;"><small><b>Fonte:</b> Algusto Caldas e Eric Rabelo</small></p>

---

### Diagrama de Componentes do Microsserviço

Representação da arquitetura do microsserviço utilizando o padrão Multiton:

<p align="center" style="font-size: 12;"><b>Figura 3:</b> Diagrama de Componentes do Microsserviço</p>

![Diagrama_de_Sequencia](../Assets/multiton-componentes-microsservico.png) 

<p align="center" style="font-size: 12;"><small><b>Fonte:</b> Algusto Caldas e Eric Rabelo</small></p>


---

### Diagrama de Estados do Recurso

Representação dos estados pelos quais um recurso pode passar:

<p align="center" style="font-size: 12;"><b>Figura 4:</b> Diagrama de Estados do Recurso</p>

![Diagrama_de_Sequencia](../Assets/multiton-estado.png) 

<p align="center" style="font-size: 12;"><small><b>Fonte:</b> Algusto Caldas e Eric Rabelo</small></p>

---

### Diagrama de Arquitetura Distribuída

Visão de como o Multiton funciona em um ambiente distribuído com múltiplos microsserviços:

<p align="center" style="font-size: 12;"><b>Figura 4:</b> Diagrama de Arquitetura Distribuída</p>

![Diagrama_de_Sequencia](../Assets/multiton-arquitetura-distribuida.png) 

<p align="center" style="font-size: 12;"><small><b>Fonte:</b> Algusto Caldas e Eric Rabelo</small></p>

---

### Fluxo de Execução

Diagrama de fluxo mostrando a lógica de decisão na criação/recuperação de instâncias:

<p align="center" style="font-size: 12;"><b>Figura 4:</b> Diagrama de Arquitetura Distribuída</p>

![Diagrama_de_Sequencia](../Assets/multiton-fluxo-execucao.png) 

<p align="center" style="font-size: 12;"><small><b>Fonte:</b> Algusto Caldas e Eric Rabelo</small></p>

---

## Vantagens do Padrão no Contexto de Microsserviços

### Benefícios Demonstrados

1. **Controle de Instâncias**: Cada tipo de recurso tem apenas uma instância de gerenciamento
2. **Eficiência de Memória**: Evita duplicação desnecessária de gerenciadores
3. **Configuração Centralizada**: Configurações consistentes por tipo de recurso
4. **Isolamento**: Diferentes tipos de recursos são gerenciados independentemente
5. **Escalabilidade**: Facilita a adição de novos tipos de recursos

### Aplicabilidade em Sistemas Reais

Este protótipo demonstra como o **Multiton** pode ser valioso em:

- **Gerenciamento de Conexões de Banco de Dados**
- **Pools de Cache Distribuído**
- **Filas de Mensagens**
- **Pools de Threads**
- **Gerenciadores de Configuração**

---

## Considerações de Implementação

### Thread Safety

Em ambientes de produção, seria necessário implementar sincronização para garantir thread safety:

```python
import threading

class ThreadSafeResourceManagerMultiton:
    _resource_managers = {}
    _lock = threading.Lock()
    
    def __new__(cls, resource_type):
        if resource_type not in cls._resource_managers:
            with cls._lock:
                if resource_type not in cls._resource_managers:
                    # Double-checked locking pattern
                    instance = super().__new__(cls)
                    # Inicialização...
                    cls._resource_managers[resource_type] = instance
        return cls._resource_managers[resource_type]
```

### Gerenciamento de Memória

Em sistemas de longa duração, considerar:
- Limpeza de instâncias não utilizadas
- Monitoramento de uso de memória
- Estratégias de cache com TTL

---

## Reflexão Crítica

Quando começamos a explorar o Multiton, confesso que a ideia de controle de instâncias não fazia muito sentido para nós no contexto do AquiTemFCTE. Tentávamos encaixar o padrão no projeto principal, mas não conseguíamos visualizar onde ele realmente agregaria valor. Foi aí que decidimos pensar fora da caixa.

Ao migrar para um mini projeto toy focado em microsserviços, tudo clareou. De repente, conseguimos ver na prática como o Multiton resolve um problema real: gerenciar múltiplas instâncias de forma controlada, onde cada tipo de recurso tem seu próprio gerenciador único. Diferente do Singleton que te prende a apenas uma instância total, o Multiton traz uma flexibilidade que faz muito mais sentido em arquiteturas modernas.

Essa experiência nos ensinou algo valioso: não existe bala de prata em arquitetura de software. Cada padrão tem seu contexto, seu momento certo de brilhar. O Multiton não era a solução para o AquiTemFCTE, mas é perfeito para sistemas que gerenciam diferentes categorias de recursos - como pools de conexão, caches distribuídos ou filas de mensagens. Aprendemos que temos um arsenal de soluções à disposição, e o segredo está em saber qual ferramenta usar para qual problema.

---

## Demonstração do Código sendo Executado

<style>
.video-container {
    position: relative;
    width: 100%;
    max-width: 800px; /* Limite a largura máxima para não ficar muito grande em desktops */
    margin: 0 auto; /* Centraliza o contêiner */
    padding-bottom: 56.25%; /* Proporção 16:9 */
    height: 0;
    overflow: hidden;
}

.video-container iframe {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
}
</style>

<div class="video-container">
<iframe width="560" height="315" src="https://www.youtube.com/embed/LkLBred92CE?si=qIgtSPH4hNlk0ABn" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
</div>

---

## Conclusão

Este documento serviu como uma demonstração explicativa do padrão **Multiton**, utilizando um **protótipo educacional** para ilustrar como ele pode centralizar a gestão de recursos e promover **robustez**, **independência** e **segurança** em arquiteturas de microsserviços.

Os diagramas apresentados ilustram como o padrão **Multiton** pode ser estruturado em um contexto de microsserviço, demonstrando sua aplicabilidade em cenários de **sistemas escalados** que requerem **robustez**, **independência** e **segurança**.

O conteúdo tem finalidade **acadêmica** e não sugere a implementação deste padrão no projeto AquiTemFCTE.

---

## Bibliografia

  * **BLACKWASP**. Multiton Design Pattern. Disponível em: [https://www.blackwasp.co.uk/multiton.html](https://www.blackwasp.co.uk/multiton.html). Acesso em: 13 out. 2025.
  * **SERRANO**, Milene. Arquitetura e Desenho de Software - Aula GoFs Criacionais. Universidade de Brasília. 2025. Disponível em: [https://aprender3.unb.br/pluginfile.php/3178542/mod_page/content/1/Arquitetura%20e%20Desenho%20de%20Software%20-%20Aula%20GoFs%20Criacionais%20-%20Profa.%20Milene.pdf](https://aprender3.unb.br/pluginfile.php/3178542/mod_page/content/1/Arquitetura%20e%20Desenho%20de%20Software%20-%20Aula%20GoFs%20Criacionais%20-%20Profa.%20Milene.pdf). Acesso em: 13 out. 2025.

---

## Histórico de Versões

| Versão | Data | Descrição | Autor(es) | Revisor(es) | Detalhes da revisão |
| :--- | :--- | :--- | :--- | :--- | :--- |
| 1.0 | 11/10/2025 | Inicialização do Documento | [Eric Rabelo](https://github.com/rabelzx) | [Algusto Caldas](https://github.com/Algusto-RC) | Revisado e Aprovado |
| 2.0 | 14/10/2025 | Integração dos diagramas ao documento principal | [Algusto Caldas](https://github.com/Algusto-RC) | [Eric Rabelo](https://github.com/rabelzx) | Revisado e Aprovado |