# 3.1.1. Builder

## 1. Padrão GOF Builder

O padrão de projeto Builder é um padrão criacional que visa separar a construção de um objeto complexo de sua representação, permitindo que o mesmo processo de construção possa criar diferentes representações. A intenção principal do Builder é encapsular a lógica de criação de um objeto, passo a passo, em um objeto construtor separado. Isso é particularmente útil quando um objeto requer a inicialização de múltiplos atributos, alguns dos quais podem ser opcionais, evitando a necessidade de construtores com uma longa lista de parâmetros — prática conhecida como telescoping constructor (GAMMA et al., 1995). Ao delegar a construção a um objeto dedicado, o código do cliente se torna mais limpo e legível, focando no "o quê" criar e não no "como" criar.

A utilização do padrão Builder promove uma maior flexibilidade sobre o processo de criação de objetos. Ele permite a construção de um objeto por etapas, validando cada passo se necessário, e somente ao final do processo o objeto completo e consistente é retornado. Essa abordagem é ideal para a criação de objetos imutáveis, pois todos os atributos são definidos de uma vez através do construtor antes que o objeto seja disponibilizado para uso. Além disso, ao isolar o código de construção e representação, o padrão facilita a adição de novas representações de um produto sem a necessidade de alterar o código de construção existente, o que está em conformidade com o princípio de aberto/fechado (SOLID), aumentando a manutenibilidade e a escalabilidade do software (MARTIN, 2003).

## 2. Metodologia

A metodologia para a aplicação do padrão de projeto Builder neste trabalho foi dividida em quatro etapas principais, partindo da análise e culminando na implementação e teste.

1. O primeiro passo consistiu na análise do [diagrama de classes](https://unbarqdsw2025-2-turma02.github.io/2025.2_T02_G6_AquiTemFCTE_Entrega_02/#/Modelagem/2.1.2.DiagramaClasses) do projeto "AquiTemFCTE". A partir dessa análise, a classe Produto foi selecionada como candidata ideal para a implementação do padrão. A justificativa para essa escolha reside na complexidade e na variedade de representações que um produto pode assumir no sistema; especificamente, a necessidade de construir objetos que representem tanto produtos destinados à venda quanto produtos disponíveis para troca. O padrão Builder é perfeitamente adequado para gerenciar essa complexidade, permitindo a criação de diferentes tipos de produtos passo a passo, garantindo que cada objeto seja instanciado com os atributos corretos para sua categoria.

2. Após a seleção da classe, o segundo passo foi a modelagem da solução utilizando o padrão GOF Builder. Para essa finalidade, foi utilizada a plataforma online [Draw.io](https://app.diagrams.net/), que permitiu a criação do diagrama de classes (conforme apresentado na Figura 1) no padrão Builder. Essa modelagem visual foi importante para definir a estrutura do Diretor, da interface do Builder e dos Builders concretos antes de iniciar a codificação.

3. O terceiro passo envolveu a seleção das tecnologias para a futura implementação e teste da modelagem. Optou-se por utilizar `TypeScript` em conjunto com `Node.js` e o framework `Express`. A escolha pelo TypeScript se deu por ser uma linguagem fortemente tipada e orientada a objetos, o que a torna mais robusta para a implementação de padrões de projeto em comparação ao JavaScript puro. O Node.js e o Express foram utilizados para simular um ambiente de servidor, permitindo testar a criação dos objetos Produto como se estivessem sendo originados a partir de uma requisição de banco de dados.

4. Finalmente, a quarta e última etapa foi a implementação efetiva do código, seguindo o que foi planejado na modelagem, e a realização de testes, conforme foi feito no Video 1, para validar o funcionamento do padrão. Essa fase garantiu que a construção dos diferentes tipos de produtos ocorresse de forma correta.

## 3. Modelagem do Builder

<p align="center" style="font-size: 12;">
Figura 1: Diagrama de Componentes
</p>

![diagrama_de_componentes](/../assets/Builder.png)

<p align="center" style="font-size: 12;">
Fonte: Daniel Rodrigues, Igor Justino
</p>

## 4. Informações Técnicas e Implementação

### 4.1. Tecnologias Utilizadas

A implementação do padrão GOF Builder foi desenvolvida utilizando as seguintes tecnologias:

- **TypeScript (v5.6.3)**: Linguagem principal escolhida por ser fortemente tipada e orientada a objetos, oferecendo maior robustez na implementação de padrões de projeto
- **Node.js**: Runtime JavaScript para execução do servidor
- **Express.js (v4.19.2)**: Framework web para criação das APIs REST
- **ts-node (v10.9.2)**: Ferramenta para execução direta de arquivos TypeScript
- **Nodemon (v3.1.10)**: Utilitário para desenvolvimento com hot reload

### 4.2. Estrutura da Implementação

A implementação seguiu fielmente a estrutura do padrão Builder, organizando o código nas seguintes classes:

#### 4.2.1. Interface ProdutoBuilder (Builder)

Esta interface define o contrato que todos os builders concretos devem seguir:

```typescript
import Produto from "./Produto";

export default interface ProdutoBuilder {
import Produto from "./Produto";

export default interface ProdutoBuilder {
  getProduto(): Produto;
  getProdutoCompleto(): Produto;
  buildVendido(): void;
  criarNovoProduto(nome: string, descricao: string): void;
  criarNovoProdutoCompleto(nome: string, descricao: string, imagem: string, preco: number, categoria: string, itemInteresse?: string[]): void;
  buildInformacoesAdicionais(foto: string, preco: number, categoria: string, itemInteresse?: string[]): void;
  buildModalidade(modalidade: string): void;
}
```

**Explicação**: A interface `ProdutoBuilder` estabelece os métodos essenciais que qualquer builder concreto deve implementar. Ela define métodos para criação de produtos básicos (`criarNovoProduto`) e completos (`criarNovoProdutoCompleto`), bem como métodos para configuração de atributos específicos e obtenção do produto final.

#### 4.2.2. Classe Produto (Product)

Classe abstrata que representa o produto sendo construído:

```typescript
type produto = {
  imagemProduto: string[];
  nomeProduto: string;
  descricaoProduto: string;
  precoProduto: number;
  categoriaProduto: string;
  estadoProduto: boolean;
  modalidadeProduto: string;
};

export default abstract class Produto {
  private imagemProduto: string[];
  private nomeProduto: string;
  private descricaoProduto: string;
  private precoProduto: number;
  private categoriaProduto: string;
  private estadoProduto: boolean;
  private modalidadeProduto: string;

  constructor(nome: string, descricao: string, modalidade?: string) {
    this.imagemProduto = [];
    this.nomeProduto = nome;
    this.descricaoProduto = descricao;
    this.precoProduto = 0;
    this.categoriaProduto = "";
    this.estadoProduto = false;
    this.modalidadeProduto = modalidade || "";
  }

  public setImagemProduto(imagem: string): void {
    this.imagemProduto.push(imagem);
  }

  public setNomeProduto(nome: string): void {
    this.nomeProduto = nome;
  }

  public setDescricaoProduto(descricao: string): void {
    this.descricaoProduto = descricao;
  }

  public setPrecoProduto(preco: number): void {
    this.precoProduto = preco;
  }

  public setCategoriaProduto(categoria: string): void {
    this.categoriaProduto = categoria;
  }

  public setModalidadeProduto(modalidade: string): void {
    this.modalidadeProduto = modalidade;
  }

  public setVendido(): void {
    this.estadoProduto = true;
  }

  public getNomeProduto(): string {
    return this.nomeProduto;
  }

  public getDescricaoProduto(): string {
    return this.descricaoProduto;
  }

  public getModalidade(): string {
    return this.modalidadeProduto;
  }

  public getProdutoCompleto(): produto {
    return {
      imagemProduto: this.imagemProduto,
      nomeProduto: this.nomeProduto,
      descricaoProduto: this.descricaoProduto,
      precoProduto: this.precoProduto,
      categoriaProduto: this.categoriaProduto,
      estadoProduto: this.estadoProduto,
      modalidadeProduto: this.modalidadeProduto,
    } as produto;
  }
}
```

**Explicação**: A classe abstrata `Produto` serve como base para todos os tipos de produtos no sistema. Ela encapsula os atributos comuns (nome, descrição, preço, categoria, etc.) e fornece métodos para manipulação segura desses dados. O uso de uma classe abstrata permite que diferentes tipos de produtos compartilhem funcionalidades comuns enquanto mantém flexibilidade para especializações.

#### 4.2.3. Classe GerenciamentoDeCriacaoProdutos (Director)

Classe responsável por orquestrar o processo de construção:

```typescript
import ProdutoBuilder from "./ProdutoBuilder";
import Produto from "./Produto";

export default class GerenciamentoDeCriacaoProdutos {
  private produtoBuilder!: ProdutoBuilder;

  public setProdutoBuilder(produtoBuilder: ProdutoBuilder): void {
    this.produtoBuilder = produtoBuilder;
  }

  public getProduto(): Produto {
    return this.produtoBuilder.getProduto();
  }

  public getProdutoCompleto(): Produto | any {
    return this.produtoBuilder.getProdutoCompleto();
  }

  public construirProduto(nomeProduto: string, descricaoProduto: string): void {
    this.produtoBuilder.criarNovoProduto(nomeProduto, descricaoProduto);
  }

  public construirProdutoCompleto(
    nomeProduto: string,
    descricaoProduto: string,
    imagemProduto: string,
    precoProduto: number,
    categoriaProduto: string,
    itemInteresse?: string[]
  ): void {
    this.produtoBuilder.criarNovoProdutoCompleto(
      nomeProduto,
      descricaoProduto,
      imagemProduto,
      precoProduto,
      categoriaProduto,
      itemInteresse
    );
  }
}
```

**Explicação**: A classe `GerenciamentoDeCriacaoProdutos` atua como o Director no padrão Builder. Ela é responsável por coordenar o processo de construção dos produtos, abstraindo a complexidade da criação do cliente. O Director conhece a sequência de passos necessária para construir um produto, mas delega a implementação específica para o builder concreto.

#### 4.2.4. Classes Builders Concretos

As implementações concretas do builder para diferentes tipos de produtos (`ProdutoVendaBuilder` e `ProdutoTrocaBuilder`) seguem a mesma estrutura, especializando-se na criação de produtos para venda e troca, respectivamente. Estes builders implementam todos os métodos da interface `ProdutoBuilder` e são responsáveis pela construção step-by-step dos objetos produto.

**1. ProdutoVendaBuilder**

```typescript
import ProdutoBuilder from "./ProdutoBuilder";
import ProdutoVenda from "./ProdutoVenda";

export default class ProdutoVendaBuilder implements ProdutoBuilder {
  protected produto?: ProdutoVenda;

  constructor() {
    this.produto = undefined;
  }

  public criarNovoProduto(nome: string, descricao: string): void {
    this.produto = new ProdutoVenda(nome, descricao, "Venda");
  }

  public criarNovoProdutoCompleto(
    nome: string,
    descricao: string,
    imagem: string,
    preco: number,
    categoria: string
  ): void {
    this.produto = new ProdutoVenda(nome, descricao, "Venda");
    this.buildInformacoesAdicionais(imagem, preco, categoria);
  }

  public getProduto(): ProdutoVenda | any {
    if (!this.produto) return {} as ProdutoVenda;
    return {
      nomeProduto: this.produto.getNomeProduto(),
      descricaoProduto: this.produto.getDescricaoProduto(),
      modalidadeProduto: this.produto.getModalidade(),
    };
  }

  public getProdutoCompleto(): ProdutoVenda {
    if (!this.produto) return {} as ProdutoVenda;
    return this.produto;
  }

  public buildInformacoesAdicionais(
    foto: string,
    preco: number,
    categoria: string
  ): void {
    if (!this.produto) throw new Error("Chame criarNovoProduto primeiro");
    this.produto.setImagemProduto(foto);
    this.produto.setPrecoProduto(preco);
    this.produto.setCategoriaProduto(categoria);
  }

  public buildVendido(): void {
    if (!this.produto) throw new Error("Chame criarNovoProduto primeiro");
    this.produto.setVendido();
  }

  public buildModalidade(modalidade: string): void {
    if (!this.produto) throw new Error("Chame criarNovoProduto primeiro");
    this.produto.setModalidadeProduto(modalidade);
  }
}
```

**2. ProdutoTrocaBuilder**

```typescript
import ProdutoBuilder from "./ProdutoBuilder";
import ProdutoTroca from "./ProdutoTroca";

export default class ProdutoTrocaBuilder implements ProdutoBuilder {
  protected produto?: ProdutoTroca;

  constructor() {
    this.produto = undefined;
  }

  public criarNovoProduto(nome: string, descricao: string): void {
    this.produto = new ProdutoTroca(nome, descricao, "Troca");
  }

  public criarNovoProdutoCompleto(
    nome: string,
    descricao: string,
    imagem: string,
    preco: number,
    categoria: string,
    itemInteresse: string[]
  ): void {
    this.produto = new ProdutoTroca(nome, descricao, "Troca");
    this.buildInformacoesAdicionais(imagem, preco, categoria, itemInteresse);
  }

  public getProduto(): ProdutoTroca | any {
    if (!this.produto) return {} as ProdutoTroca;
    return {
      nomeProduto: this.produto.getNomeProduto(),
      descricaoProduto: this.produto.getDescricaoProduto(),
      modalidadeProduto: this.produto.getModalidade(),
    };
  }

  public getProdutoCompleto(): ProdutoTroca {
    if (!this.produto) return {} as ProdutoTroca;
    return this.produto;
  }

  public buildInformacoesAdicionais(
    foto: string,
    preco: number,
    categoria: string,
    itemInteresse: string[]
  ): void {
    if (!this.produto) throw new Error("Chame criarNovoProduto primeiro");
    if (!itemInteresse || itemInteresse.length === 0)
      throw new Error(
        "Em trocas, a lista de itens de interesse não pode ser vazia"
      );
    this.produto.setImagemProduto(foto);
    this.produto.setPrecoProduto(preco);
    this.produto.setCategoriaProduto(categoria);
    this.produto.setItensDeInteresseParaTroca(itemInteresse);
  }

  public buildVendido(): void {
    if (!this.produto) throw new Error("Chame criarNovoProduto primeiro");
    this.produto.setVendido();
  }

  public buildModalidade(modalidade: string): void {
    if (!this.produto) throw new Error("Chame criarNovoProduto primeiro");
    this.produto.setModalidadeProduto(modalidade);
  }
}
```

#### 4.2.5. Camada de Serviço

```typescript
import { Router } from "express";
import ProdutoBuilder from "../class/ProdutoBuilder";
import ProdutoVendaBuilder from "../class/ProdutoVendaBuilder";
import ProdutoTrocaBuilder from "../class/ProdutoTrocaBuilder";
import GerenciamentoDeCriacaoProdutos from "../class/GerenciadorDeCriacaoProdutos";

const router = Router();

export default class ProdutoService {
  public router: Router;

  constructor() {
    this.router = router;
  }

  public criarProdutoBasico(): void {
    this.router.post("/basic", (req, res) => {
      try {
        const produto = req.body;

        if (
          !produto.tipo ||
          (produto.tipo !== "Troca" && produto.tipo !== "Venda")
        ) {
          res
            .status(400)
            .send({
              error: "Tipo de produto inválido. Use 'Troca' ou 'Venda'.",
            });
          return;
        }

        const produtoBuilder: ProdutoBuilder =
          produto.tipo === "Troca"
            ? new ProdutoTrocaBuilder()
            : new ProdutoVendaBuilder();

        const director = new GerenciamentoDeCriacaoProdutos();
        director.setProdutoBuilder(produtoBuilder);

        director.construirProduto(produto.nome, produto.descricao);
        const novoProduto = director.getProduto();

        res.status(201).send(novoProduto);
      } catch (error) {
        res.status(500).send({ error: (error as Error).message });
      }
    });
  }

  public criarProdutoCompleto(): void {
    this.router.post("/full", (req, res) => {
      try {
        const produto = req.body;

        if (
          !produto.tipo ||
          (produto.tipo !== "Troca" && produto.tipo !== "Venda")
        ) {
          res
            .status(400)
            .send({
              error: "Tipo de produto inválido. Use 'Troca' ou 'Venda'.",
            });
          return;
        }

        const produtoBuilder: ProdutoBuilder =
          produto.tipo === "Troca"
            ? new ProdutoTrocaBuilder()
            : new ProdutoVendaBuilder();

        const director = new GerenciamentoDeCriacaoProdutos();
        director.setProdutoBuilder(produtoBuilder);

        director.construirProdutoCompleto(
          produto.nome,
          produto.descricao,
          produto.imagem,
          produto.preco,
          produto.categoria,
          produto.itensDeInteresseParaTroca
        );

        const novoProduto = director.getProdutoCompleto();

        res.status(200).send(novoProduto);
      } catch (error) {
        res.status(500).send({ error: (error as Error).message });
      }
    });
  }
}
```

**Explicação**: A classe `ProdutoService` integra o padrão Builder com a API REST, demonstrando como o padrão pode ser utilizado em uma aplicação web real. O serviço recebe requisições HTTP, determina qual builder utilizar baseado no tipo de produto solicitado, e orquestra a criação através do Director.

## 5. Como executar a Implementação

Para executar a implementação do padrão Builder desenvolvida, siga os seguintes passos:

### 5.1. Pré-requisitos

- **Node.js** (versão 16 ou superior)
- **npm** (gerenciador de pacotes do Node.js)
- **Postman** (para testar as requisições HTTP) ou similar (Insomnia, Thunder Client, etc.)

### 5.2. Passos para Execução

#### Passo 1: Navegue até o diretório do projeto

```bash
cd GOFs/Criacionais/Builder
```

#### Passo 2: Instale as dependências

```bash
npm install
```

#### Passo 3: Execute o servidor

```bash
npm start
```

O servidor será iniciado em `http://localhost:3001` e você verá a seguinte mensagem:

```
[nodemon] starting `ts-node src/index.ts`
Servidor rodando em http://localhost:3001

UTILIZE O POSTMAN OU INSOMNIA PARA TESTAR AS REQUISIÇÕES POST:
- http://localhost:3001/produto/basic
- http://localhost:3001/produto/full

EXEMPLO DE REQUISIÇÃO PARA PRODUTO BÁSICO (BODY):
{
  "nome": "Camiseta",
  "descricao": "Camiseta de algodão tamanho M",
  "tipo": "Venda"
}

EXEMPLO DE REQUISIÇÃO PARA PRODUTO COMPLETO (BODY):
{
  "nome": "Camiseta",
  "descricao": "Camiseta de algodão tamanho M",
  "imagem": "http://exemplo.com/imagem.jpg",
  "preco": 49.90,
  "categoria": "Roupas",
  "tipo": "Troca",
  "itensDeInteresseParaTroca": ["Produto A", "Produto B"]
}
```

#### Passo 4: Teste a API usando Postman

##### 4.1. Criação de Produto Básico (Troca)

- **Método**: POST
- **URL**: `http://localhost:3001/produto/basic`
- **Headers**:
  - `Content-Type: application/json`
- **Body (JSON)**:

```json
{
  "nome": "Camiseta",
  "descricao": "Camiseta de algodão tamanho M",
  "tipo": "Troca"
}
```

**Resposta esperada**:

```json
{
  "nomeProduto": "Fone de Ouvido JBL",
  "descricaoProduto": "Este fone não existe e é um teste",
  "modalidadeProduto": "Troca"
}
```

##### 4.2. Criação de Produto Básico (Venda)

- **Método**: POST
- **URL**: `http://localhost:3001/produto/basic`
- **Headers**:
  - `Content-Type: application/json`
- **Body (JSON)**:

```json
{
  "nome": "Smartphone Samsung Galaxy",
  "descricao": "Celular em ótimo estado",
  "tipo": "Venda"
}
```

##### 4.3. Criação de Produto Completo

- **Método**: POST
- **URL**: `http://localhost:3001/produto/full`
- **Headers**:
  - `Content-Type: application/json`
- **Body (JSON)**:

```json
{
  "nome": "Notebook Dell Inspiron",
  "descricao": "Notebook para uso profissional",
  "tipo": "Venda",
  "imagem": "notebook_dell.jpg",
  "preco": 2500.0,
  "categoria": "Eletrônicos"
}
```

### 5.3. Endpoints Disponíveis

| Método | Endpoint         | Descrição                                 |
| ------ | ---------------- | ----------------------------------------- |
| POST   | `/produto/basic` | Cria um produto com informações básicas   |
| POST   | `/produto/full`  | Cria um produto com informações completas |

### 5.4. Parâmetros de Entrada

#### Para `/produto/basic`:

- `nome` (string, obrigatório): Nome do produto
- `descricao` (string, obrigatório): Descrição do produto
- `tipo` (string, obrigatório): "Troca" ou "Venda"

#### Para `/produto/full`:

- Todos os parâmetros do `/basic`
- `imagem` (string, opcional): URL ou nome da imagem
- `preco` (number, opcional): Preço do produto
- `categoria` (string, opcional): Categoria do produto
- `itemDeInteresseParaTroca` (string, obrigatório ser for do tipo "Troca'): Lista de itens para troca.

### 5.5. Scripts Disponíveis

- `npm start`: Inicia o servidor em modo desenvolvimento com hot reload

## 7. Vídeo de Execução do Código e Local do Código:

### Vídeo de Execução:

### Local do Builder no Repositório

[Clique Aqui para Acessar o Local do Código no Repositório](https://github.com/UnBArqDsw2025-2-Turma02/2025.2_T02_G6_AquiTemFCTE_Entrega_03/tree/main/GOFs/Criacionais/Builder)

## 8. Senso Crítico e Trabalho em Equipe

### Justificativas e Senso Crítico

A aplicação do padrão GOF Builder no contexto do projeto "AquiTemFCTE" demonstrou ser uma decisão arquitetural extremamente acertada, especialmente quando analisamos a complexidade inerente à representação de produtos em um sistema de troca e venda. O padrão nos permitiu ir além da simples criação de objetos e, em vez disso, estruturar um sistema que pode acomodar diferentes tipos de produtos sem comprometer a integridade do código.

Este padrão não apenas solucionou o problema imediato de construção de objetos complexos, mas também serviu como uma base sólida para futuras extensões do sistema, direcionando o desenvolvimento para uma arquitetura escalável e garantindo que cada novo tipo de produto possa ser facilmente integrado sem impactar o código existente. A separação clara entre a construção e a representação dos objetos revelou-se essencial para manter a coesão do sistema e facilitar a manutenção a longo prazo.

### Comentários sobre o Trabalho em Equipe

A fase inicial de análise conjunta permitiu que ambos da equipe compreendessem profundamente os requisitos do domínio e as nuances do padrão a ser implementado. Em seguida, a divisão de tarefas por componentes específicos — onde cada desenvolvedor ficou responsável por diferentes classes do padrão — criou um ambiente de especialização que resultou em código de maior qualidade e aderência aos princípios do padrão.

Acreditamos que este trabalho conjunto, alternando momentos de desenvolvimento individual com sessões frequentes de revisão e integração, permitiu não apenas a detecção precoce de inconsistências de design, mas também o compartilhamento contínuo de conhecimento entre a equipe. As discussões sobre implementação específica e as decisões arquiteturais tomadas coletivamente resultaram em uma solução mais fundamentada do que seria possível em um desenvolvimento puramente individual.

## 9. Conclusão

A implementação do padrão GOF Builder no projeto "AquiTemFCTE" representou muito mais do que a simples aplicação de um padrão de projeto; constituiu uma demonstração prática de como princípios sólidos de engenharia de software podem ser aplicados para resolver problemas complexos do mundo real. O padrão Builder revelou-se particularmente adequado ao domínio de produtos de troca e venda, onde a diversidade de representações e a necessidade de flexibilidade na construção de objetos são aspectos centrais do sistema.

O processo de desenvolvimento, desde a análise inicial do domínio até a implementação final e testes, evidenciou a importância de uma metodologia estruturada na aplicação de padrões de projeto. A modelagem prévia utilizando diagramas UML mostrou-se fundamental para a compreensão da estrutura do padrão e sua adaptação ao contexto específico do projeto. A escolha do TypeScript como linguagem de implementação proporcionou não apenas robustez através da tipagem estática, mas também uma expressividade que facilitou a implementação fiel dos conceitos do padrão.

Os resultados obtidos demonstram que a implementação não apenas atende aos requisitos funcionais estabelecidos, mas também estabelece uma base arquitetural sólida para futuras expansões do sistema. A flexibilidade introduzida pelo padrão Builder permite que novos tipos de produtos sejam facilmente incorporados, enquanto a separação clara de responsabilidades facilita a manutenção e evolução do código.

## 10. Referências

> GAMMA, E. et al. **Padrões de Projeto: Soluções Reutilizáveis de Software Orientado a Objetos**. Porto Alegre: Bookman, 1995.

> MARTIN, R. C. **Princípios, Padrões e Práticas Ágeis em C#**. Porto Alegre: Bookman, 2003.

> FREEMAN, E.; FREEMAN, E.; BATES, B.; SIERRA, K. **Use a Cabeça! Padrões de Projetos**. 2. ed. Rio de Janeiro: Alta Books, 2007.

> FOWLER, M. **Refactoring: Improving the Design of Existing Code**. 2. ed. Boston: Addison-Wesley Professional, 2018.

> MICROSOFT. **TypeScript Documentation**. Disponível em: https://www.typescriptlang.org/docs/. Acesso em: 13 out. 2025.

> EXPRESS.JS. **Express - Node.js web application framework**. Disponível em: https://expressjs.com/. Acesso em: 13 out. 2025.

## Histórico de Versões

| Versão | Data       | Descrição                                | Autor(es)                             | Revisor(es) | Detalhes da Revisão                                                |
| ------ | ---------- | ---------------------------------------- | ------------------------------------- | ----------- | ------------------------------------------------------------------ |
| 1.0    | 13/10/2025 | Criação do Diagrama                      | [Daniel Rodrigues]() [Igor Justino]() | []()        | Revisão sem erros identificados, seções adicionais são necessários |
| 1.1    | 13/10/2025 | Implementação completa do padrão Builder | [Daniel Rodrigues]() []()                 | []()        | Sem erro no que foi produzido, mas falta video e um link para indicar a pasta da implementação do GOF |
| 1.2    | 13/10/2025 | Inserção do Código GOF | [Daniel Rodrigues]() | []() | Sem erro no que foi produzido, falta inserção do video |
