# 3.2.2. Proxy

## 1. Padrão GOF Proxy

O padrão de projeto Proxy é um padrão estrutural que fornece um substituto ou marcador de posição para outro objeto, controlando o acesso a ele. A intenção principal do Proxy é criar um intermediário que controla e gerencia o acesso ao objeto real, permitindo adicionar funcionalidades extras como controle de acesso, lazy loading, logging, cache ou validação de requisições antes de encaminhar a solicitação ao objeto verdadeiro (GAMMA et al., 1995). Este padrão é particularmente útil quando se deseja proteger um objeto, adiar sua criação até que seja realmente necessário, ou adicionar uma camada de segurança e controle sem modificar o código do objeto original.

A utilização do padrão Proxy promove maior segurança e controle sobre o acesso aos objetos do sistema. Ele atua como um "guardião" que intercepta todas as requisições antes de encaminhá-las ao objeto real, podendo aplicar regras de negócio, validações e restrições de acesso. Esta abordagem está em conformidade com o princípio da responsabilidade única (Single Responsibility Principle) do SOLID, uma vez que separa a lógica de controle de acesso da lógica de negócio principal. Além disso, o padrão facilita a adição de novas funcionalidades de controle sem alterar o código existente, respeitando o princípio aberto/fechado e aumentando a manutenibilidade e segurança do software (MARTIN, 2003).

## 2. Metodologia

A metodologia para a aplicação do padrão de projeto Proxy neste trabalho foi dividida em quatro etapas principais, partindo da análise e culminando na implementação e teste.

1. O primeiro passo consistiu na análise do [diagrama de classes](https://unbarqdsw2025-2-turma02.github.io/2025.2_T02_G6_AquiTemFCTE_Entrega_02/#/Modelagem/2.1.2.DiagramaClasses) do projeto "AquiTemFCTE". A partir dessa análise, identificou-se a necessidade de implementar um sistema anti-spam para o serviço de mensagens da plataforma. A justificativa para essa escolha reside na importância de prevenir abusos, spam e assédio entre usuários em plataformas de marketplace, garantindo uma experiência segura e de qualidade. O padrão Proxy é perfeitamente adequado para gerenciar essa proteção, interceptando e validando cada requisição de envio de mensagem antes de encaminhá-la ao serviço real, aplicando regras como: limite diário de mensagens (20/dia), limite por destinatário (5 mensagens/dia), e verificação de idade da conta (mínimo 24h).

2. Após a identificação da necessidade, o segundo passo foi a modelagem da solução utilizando o padrão GOF Proxy. Para essa finalidade, foi utilizada a plataforma online [Draw.io](https://app.diagrams.net/), que permitiu a criação do diagrama de classes (conforme apresentado na Figura 1) no padrão Proxy. Essa modelagem visual foi importante para definir a estrutura da interface comum (Subject), o serviço real (RealSubject) e o Proxy com suas regras anti-spam antes de iniciar a codificação.

3. O terceiro passo envolveu a seleção das tecnologias para a futura implementação e teste da modelagem. Optou-se por utilizar `TypeScript` em conjunto com `Node.js`. A escolha pelo TypeScript se deu por ser uma linguagem fortemente tipada e orientada a objetos, o que a torna mais robusta para a implementação de padrões de projeto em comparação ao JavaScript puro. O Node.js foi utilizado para executar o código TypeScript e simular o comportamento do serviço de mensagens com as regras anti-spam.

4. Finalmente, a quarta e última etapa foi a implementação efetiva do código, seguindo o que foi planejado na modelagem, e a realização de testes para validar o funcionamento do padrão. Essa fase garantiu que o sistema anti-spam funcionasse corretamente, bloqueando contas muito recentes (menos de 24h), usuários que excedem o limite diário e tentativas de spam para o mesmo destinatário.

## 3. Modelagem do Proxy

<p align="center" style="font-size: 12;">
Figura 1: Diagrama de Classes - Padrão Proxy
</p>

![diagrama_de_classes_proxy](docs/assets/Proxy.png)

<p align="center" style="font-size: 12;">
Fonte: Felipe Camelo, Igor Justino
</p>

## 4. Informações Técnicas e Implementação

### 4.1. Tecnologias Utilizadas

A implementação do padrão GOF Proxy foi desenvolvida utilizando as seguintes tecnologias:

- **TypeScript (v5.0.0)**: Linguagem principal escolhida por ser fortemente tipada e orientada a objetos, oferecendo maior robustez na implementação de padrões de projeto
- **Node.js**: Runtime JavaScript para execução do código
- **ts-node (v10.9.0)**: Ferramenta para execução direta de arquivos TypeScript
- **@types/node (v20.0.0)**: Definições de tipos do Node.js para TypeScript

### 4.2. Estrutura da Implementação

A implementação seguiu fielmente a estrutura do padrão Proxy, organizando o código nas seguintes classes e interfaces:

#### 4.2.1. Interface IServiceResponse

Esta interface define a estrutura padrão de resposta dos serviços:

```typescript
export interface IServiceResponse {
  success: boolean;
  message: string;
}
```

**Explicação**: A interface `IServiceResponse` estabelece um contrato de resposta uniforme para todos os serviços da aplicação. Ela define dois campos essenciais: `success` para indicar o resultado da operação e `message` para fornecer detalhes sobre o resultado, seja sucesso ou erro.

#### 4.2.2. Interface IMessageService (Subject)

Interface que define o contrato que tanto o serviço real quanto o proxy devem seguir:

```typescript
import { IServiceResponse } from './IServiceResponse';

export interface IMessageService {
  sendMessage(senderEmail: string, receiverEmail: string, message: string): IServiceResponse;
}
```

**Explicação**: A interface `IMessageService` atua como o **Subject** no padrão Proxy. Ela define o contrato comum que tanto o `RealMessageService` quanto o `MessageServiceProxy` devem implementar, garantindo que ambos possam ser usados de forma intercambiável pelo cliente.

#### 4.2.3. Classe RealMessageService (RealSubject)

Classe que implementa o serviço real de mensagens:

```typescript
import { IMessageService } from '../interfaces/IMessageService';
import { IServiceResponse } from '../interfaces/IServiceResponse';

export class RealMessageService implements IMessageService {
  public sendMessage(senderEmail: string, receiverEmail: string, message: string): IServiceResponse {
    console.log(`[RealService] Enviando mensagem de ${senderEmail} para ${receiverEmail}...`);

    return {
      success: true,
      message: 'Mensagem enviada com sucesso.'
    };
  }
}
```

**Explicação**: A classe `RealMessageService` representa o **RealSubject** no padrão Proxy. É o objeto real que contém a lógica de negócio principal - o envio efetivo de mensagens. Esta classe simula o envio de mensagens e, em um cenário real, integraria com APIs externas, banco de dados ou serviços de e-mail.

#### 4.2.4. Classe MessageServiceProxy (Proxy)

Classe que atua como proxy com sistema anti-spam, controlando o acesso ao serviço real:

```typescript
import { IMessageService } from '../interfaces/IMessageService';
import { IServiceResponse } from '../interfaces/IServiceResponse';

export class MessageServiceProxy implements IMessageService {
  private realService: IMessageService;
  private messageCounts: Map<string, number> = new Map();
  private messagesByRecipient: Map<string, Map<string, number>> = new Map();
  private accountCreationDates: Map<string, Date> = new Map();

  constructor(realService: IMessageService) {
    this.realService = realService;
    this.initializeMockData();
  }

  private initializeMockData(): void {
    this.accountCreationDates.set('aluno@universidade.edu.br', new Date(Date.now() - 48 * 60 * 60 * 1000));
    this.accountCreationDates.set('novato@universidade.edu.br', new Date(Date.now() - 12 * 60 * 60 * 1000));
  }

  public sendMessage(senderEmail: string, receiverEmail: string, message: string): IServiceResponse {
    console.log('[Proxy] Interceptando a solicitação de envio de mensagem...');

    if (!this.isAccountOldEnough(senderEmail)) {
      console.log('[Proxy] BLOQUEADO: Conta muito recente (mínimo 24h).');
      return {
        success: false,
        message: 'Sua conta deve ter pelo menos 24 horas para enviar mensagens.'
      };
    }

    if (!this.checkDailyLimit(senderEmail)) {
      console.log('[Proxy] BLOQUEADO: Limite diário de mensagens excedido.');
      return {
        success: false,
        message: 'Você atingiu o limite de 20 mensagens por dia. Tente novamente amanhã.'
      };
    }

    if (!this.checkRecipientLimit(senderEmail, receiverEmail)) {
      console.log('[Proxy] BLOQUEADO: Limite de mensagens para este destinatário excedido.');
      return {
        success: false,
        message: 'Você atingiu o limite de 5 mensagens para este destinatário hoje.'
      };
    }

    console.log('[Proxy] ✓ Validações anti-spam aprovadas. Encaminhando ao serviço real...');
    this.incrementMessageCount(senderEmail, receiverEmail);
    return this.realService.sendMessage(senderEmail, receiverEmail, message);
  }

  private isAccountOldEnough(email: string): boolean {
    const creationDate = this.accountCreationDates.get(email);
    if (!creationDate) return false;
    const hoursSinceCreation = (Date.now() - creationDate.getTime()) / (1000 * 60 * 60);
    return hoursSinceCreation >= 24;
  }

  private checkDailyLimit(senderEmail: string): boolean {
    const count = this.messageCounts.get(senderEmail) || 0;
    return count < 20;
  }

  private checkRecipientLimit(senderEmail: string, receiverEmail: string): boolean {
    const recipientMap = this.messagesByRecipient.get(senderEmail);
    if (!recipientMap) return true;
    const count = recipientMap.get(receiverEmail) || 0;
    return count < 5;
  }

  private incrementMessageCount(senderEmail: string, receiverEmail: string): void {
    const currentCount = this.messageCounts.get(senderEmail) || 0;
    this.messageCounts.set(senderEmail, currentCount + 1);
    if (!this.messagesByRecipient.has(senderEmail)) {
      this.messagesByRecipient.set(senderEmail, new Map());
    }
    const recipientMap = this.messagesByRecipient.get(senderEmail)!;
    const recipientCount = recipientMap.get(receiverEmail) || 0;
    recipientMap.set(receiverEmail, recipientCount + 1);
  }
}
```

**Explicação**: A classe `MessageServiceProxy` é o **Proxy** propriamente dito, implementando um sistema anti-spam robusto. Ela mantém três estruturas de dados: `messageCounts` para rastrear mensagens diárias por usuário, `messagesByRecipient` para controlar mensagens por destinatário, e `accountCreationDates` para verificar a idade das contas. Antes de delegar ao serviço real, o proxy executa três validações críticas: (1) verifica se a conta tem pelo menos 24 horas de criação, prevenindo contas recém-criadas de spammar; (2) verifica o limite diário de 20 mensagens por usuário; (3) verifica o limite de 5 mensagens para o mesmo destinatário. Se qualquer validação falha, o proxy bloqueia a operação com mensagem explicativa; caso contrário, incrementa os contadores e encaminha a requisição ao serviço real. Esta implementação protege a plataforma contra spam, assédio e abuso do sistema de mensagens.

#### 4.2.5. Classe App (Cliente)

Classe cliente que demonstra o uso do padrão Proxy com diversos cenários de teste:

```typescript
import { IMessageService } from './interfaces/IMessageService';
import { RealMessageService } from './services/RealMessageService';
import { MessageServiceProxy } from './services/MessageServiceProxy';

class App {
  public static main(): void {
    console.log('========================================');
    console.log('   SISTEMA ANTI-SPAM DE MENSAGENS');
    console.log('========================================\n');

    const realService = new RealMessageService();
    const proxyService: IMessageService = new MessageServiceProxy(realService);

    console.log('--- Teste 1: Usuário com conta válida (48h) ---');
    const response1 = proxyService.sendMessage(
      'aluno@universidade.edu.br',
      'professor@universidade.edu.br',
      'Olá, professor! Gostaria de trocar/comprar seu livro.'
    );
    console.log('Resultado:', response1);

    console.log('\n--- Teste 2: Conta muito recente (12h) - BLOQUEIO ---');
    const response2 = proxyService.sendMessage(
      'novato@universidade.edu.br',
      'vendedor@universidade.edu.br',
      'Oi, tenho interesse no produto.'
    );
    console.log('Resultado:', response2);

    console.log('\n--- Teste 3: Simulando múltiplas mensagens para o mesmo destinatário ---');
    for (let i = 2; i <= 6; i++) {
      console.log(`\n  Mensagem ${i}:`);
      const response = proxyService.sendMessage(
        'aluno@universidade.edu.br',
        'professor@universidade.edu.br',
        `Mensagem número ${i}`
      );
      console.log('  Resultado:', response.success ? '✓ Enviada' : '✗ Bloqueada');
      if (!response.success) {
        console.log('  Motivo:', response.message);
        break;
      }
    }

    console.log('\n--- Teste 4: Enviando para destinatários diferentes ---');
    const destinatarios = ['usuario1@universidade.edu.br', 'usuario2@universidade.edu.br'];
    destinatarios.forEach((dest, index) => {
      console.log(`\n  Mensagem ${index + 1} para ${dest}:`);
      const response = proxyService.sendMessage('aluno@universidade.edu.br', dest, 'Olá!');
      console.log('  Resultado:', response.success ? '✓ Enviada' : '✗ Bloqueada');
    });
  }
}

App.main();
```

**Explicação**: A classe `App` demonstra como o cliente utiliza o padrão Proxy de forma transparente. O código realiza quatro testes diferentes: (1) envio normal com conta válida; (2) tentativa de envio com conta recente que é bloqueada; (3) teste de limite por destinatário, enviando 6 mensagens e sendo bloqueado na 6ª; (4) envio para múltiplos destinatários diferentes. O cliente não sabe que está usando um proxy - ele apenas chama `sendMessage()` através da interface `IMessageService`, e todas as validações anti-spam acontecem de forma transparente no proxy antes de atingir o serviço real.

## 5. Como executar a Implementação

Para executar a implementação do padrão Proxy desenvolvida, siga os seguintes passos:

### 5.1. Pré-requisitos

- **Node.js** (versão 16 ou superior)
- **npm** (gerenciador de pacotes do Node.js)

### 5.2. Passos para Execução

#### Passo 1: Navegue até o diretório do projeto

```bash
cd GOFs/Estruturais/proxy
```

#### Passo 2: Instale as dependências

```bash
npm install
```

#### Passo 3: Execute a aplicação

```bash
npm start
```

### 5.3. Saída Esperada

Ao executar o comando `npm start`, você verá a seguinte saída no terminal demonstrando as validações anti-spam:

```
========================================
   SISTEMA ANTI-SPAM DE MENSAGENS
========================================

--- Teste 1: Usuário com conta válida (48h) ---
[Proxy] Interceptando a solicitação de envio de mensagem...
[Proxy] ✓ Validações anti-spam aprovadas. Encaminhando ao serviço real...
[RealService] Enviando mensagem de aluno@universidade.edu.br para professor@universidade.edu.br...
Resultado: { success: true, message: 'Mensagem enviada com sucesso.' }

--- Teste 2: Conta muito recente (12h) - BLOQUEIO ---
[Proxy] Interceptando a solicitação de envio de mensagem...
[Proxy] BLOQUEADO: Conta muito recente (mínimo 24h).
Resultado: {
  success: false,
  message: 'Sua conta deve ter pelo menos 24 horas para enviar mensagens.'
}

--- Teste 3: Simulando múltiplas mensagens do mesmo usuário ---
  Mensagem 2 para o mesmo destinatário:
[Proxy] Interceptando a solicitação de envio de mensagem...
[Proxy] ✓ Validações anti-spam aprovadas. Encaminhando ao serviço real...
  Resultado: ✓ Enviada

  [... mensagens 3, 4 e 5 também são enviadas ...]

  Mensagem 6 para o mesmo destinatário:
[Proxy] Interceptando a solicitação de envio de mensagem...
[Proxy] BLOQUEADO: Limite de mensagens para este destinatário excedido.
  Resultado: ✗ Bloqueada
  Motivo: Você atingiu o limite de 5 mensagens para este destinatário hoje.

--- Teste 4: Enviando para destinatários diferentes ---
  Mensagem 1 para usuario1@universidade.edu.br:
[Proxy] ✓ Validações anti-spam aprovadas. Encaminhando ao serviço real...
  Resultado: ✓ Enviada

  Mensagem 2 para usuario2@universidade.edu.br:
[Proxy] ✓ Validações anti-spam aprovadas. Encaminhando ao serviço real...
  Resultado: ✓ Enviada

========================================
   FIM DOS TESTES
========================================
```

### 5.4. Scripts Disponíveis

- `npm start`: Executa a aplicação usando ts-node
- `npm run build`: Compila o código TypeScript para JavaScript (pasta dist/)
- `npm run dev`: Executa em modo desenvolvimento com hot reload (se disponível)

## 6. Vídeo de Execução do Código e Local do Código

### Vídeo de Execução:

<iframe width="560" height="315" src="https://www.youtube.com/embed/VIDEO_ID_PROXY" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>

### Local do Proxy no Repositório

[Clique Aqui para Acessar o Local do Código no Repositório](https://github.com/UnBArqDsw2025-2-Turma02/2025.2_T02_G6_AquiTemFCTE_Entrega_03/tree/main/GOFs/Estruturais/proxy)

## 7. Senso Crítico e Trabalho em Equipe

### Justificativas e Senso Crítico

A aplicação do padrão GOF Proxy no contexto do projeto "AquiTemFCTE" demonstrou ser uma decisão arquitetural extremamente acertada, especialmente ao implementar um sistema anti-spam robusto para o serviço de mensagens da plataforma. Em plataformas de marketplace, onde usuários interagem frequentemente através de mensagens para negociar trocas e vendas, a proteção contra spam e assédio é fundamental para manter a qualidade da experiência do usuário e a integridade da comunidade.

O Proxy implementado resolve três problemas críticos de forma elegante: (1) previne que contas recém-criadas (menos de 24h) enviem mensagens, dificultando ataques automatizados e spam; (2) limita mensagens diárias por usuário (máx. 20/dia), prevenindo abuso massivo do sistema; (3) controla mensagens por destinatário (máx. 5/dia), protegendo usuários contra assédio e spam direcionado. Esta implementação multi-camada oferece proteção robusta sem comprometer a usabilidade para usuários legítimos.

A arquitetura escolhida está em total conformidade com os princípios SOLID. O Single Responsibility Principle (SRP) é respeitado ao separar completamente a lógica anti-spam da lógica de envio de mensagens. O Open/Closed Principle (OCP) permite adicionar novas regras de validação (como detecção de palavras-chave suspeitas ou análise de reputação) sem modificar o serviço real ou o código cliente. Esta separação também facilita testes unitários, permitindo testar o sistema anti-spam independentemente do serviço de mensagens real.

### Comentários sobre o Trabalho em Equipe

O desenvolvimento do padrão Proxy foi realizado de forma colaborativa, com sessões de pair programming e revisões constantes de código. A equipe iniciou com uma análise conjunta dos requisitos de segurança do sistema, identificando pontos onde o controle de acesso era crítico. A divisão de tarefas permitiu que um desenvolvedor focasse na implementação do serviço real e das interfaces, enquanto o outro se concentrava na lógica de validação e controle do proxy.

As discussões técnicas durante o desenvolvimento foram fundamentais para definir quais validações implementar no proxy e como estruturar as mensagens de erro. A metodologia de trabalho adotada - alternando entre desenvolvimento individual e revisões em conjunto - resultou em um código mais robusto e bem documentado. O processo de revisão cruzada permitiu identificar casos extremos e melhorias na lógica de validação antes dos testes finais.

## 8. Conclusão

A implementação do padrão Proxy no sistema de mensagens do AquiTemFCTE demonstra como esse padrão estrutural pode resolver problemas reais de segurança e usabilidade em uma aplicação de marketplace universitário. O sistema anti-spam desenvolvido protege os usuários contra práticas abusivas, como spam e assédio, mantendo a experiência de comunicação fluida para usuários legítimos através de três camadas de validação: idade mínima da conta, limite diário de mensagens e limite por destinatário.

A arquitetura baseada no padrão Proxy proporcionou uma separação clara de responsabilidades, permitindo que a lógica anti-spam seja mantida independentemente do serviço real de mensagens. Esta separação facilita futuras expansões, como a adição de detecção de conteúdo inadequado, análise de padrões de comportamento suspeito ou integração com sistemas de reputação de usuários. A conformidade com os princípios SOLID garante que o código seja facilmente testável, extensível e manutenível.

O padrão Proxy se mostrou especialmente adequado para este cenário, pois adiciona controles de segurança de forma transparente para o código cliente, sem aumentar a complexidade da interface `IMessageService`. Esta implementação pode servir como base para outras funcionalidades de controle de acesso no AquiTemFCTE, como moderação de anúncios, gerenciamento de avaliações ou controle de acesso a dados sensíveis.

## 9. Referências

> GAMMA, Erich; HELM, Richard; JOHNSON, Ralph; VLISSIDES, John. **Design Patterns: Elements of Reusable Object-Oriented Software**. Addison-Wesley, 1994.

> REFACTORING GURU. **Proxy design pattern**. Disponível em: https://refactoring.guru/design-patterns/proxy. Acesso em: 25 maio 2025.

> REFACTORING.GURU. **Padrão de Projeto Proxy**. Refactoring.Guru, 2024. Disponível em: https://refactoring.guru/design-patterns/proxy. Acesso em: 29 maio 2025.
     

## Histórico de Versões

| Versão | Data       | Descrição                                | Autor(es)                             | Revisor(es) | Detalhes da Revisão                                                |
| ------ | ---------- | ---------------------------------------- | ------------------------------------- | ----------- | ------------------------------------------------------------------ |
| 1.0    | 16/10/2025 | Criação do diagrama| [Igor Justino](https://github.com/IgorJustino) | [Felipe Camelo](https://github.com/felipeacampelo)        |  |
| 1.1    | 17/10/2025 | Implementação completa do padrão Proxy  |[Igor Justino](https://github.com/IgorJustino) | [Felipe Camelo](https://github.com/felipeacampelo)        |  |
|                     
