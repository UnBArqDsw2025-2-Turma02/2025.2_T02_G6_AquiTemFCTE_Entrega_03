<style>
    .markdown-section table {
        justify-items: center;
    }

    img{
        max-height: 300px;
        justify-items: center;
    }

</style>

# 3.1.3. Factory Method

## Introdução

O padrão _Factory Method_ é um dos padrões de projeto criacionais propostos pela _Gang of Four_ (GoF). Seu principal objetivo é delegar a responsabilidade de criação de objetos às subclasses, promovendo baixo acoplamento e maior flexibilidade na arquitetura do sistema.

Conforme destacado por LARMAN (2007), o _Factory Method_ pode ser compreendido como um caso particular do _Template Method_, no qual a operação primitiva é responsável pela criação de instâncias de classes concretas. Essa abordagem é amplamente utilizada no desenvolvimento de _frameworks_, pois permite que superclasses definam métodos de criação e deixem que as subclasses concretas determinem qual tipo específico de objeto será instanciado. Tal característica reforça a extensibilidade e a reutilização de código, princípios centrais da engenharia de software orientada a objetos.

## Metodologia

Neste projeto, o padrão _Factory Method_ foi implementado com o objetivo de gerenciar o processo de criação de diferentes tipos de usuários dentro da plataforma (especificamente, estudantes (`Student`) e administradores (`Admin`)). Ambos compartilham os atributos e comportamentos definidos na classe base `User`, porém são instanciados de forma independente por meio de fábricas especializadas (`StudentCreator` e `AdminCreator`).

A aplicação do padrão foi conduzida a partir do estudo teórico do conceito e da análise das classes que apresentavam comportamentos compatíveis com sua proposta. A partir disso, foi elaborado um diagrama UML (Figura 1), representando a estrutura e as relações entre as classes envolvidas na implementação do _Factory Method_ para a entidade `User`.

Após o desenho da modelagem UML, a implementação foi realizada em três etapas:

1. Definição das classes abstratas e fábricas concretas em `backend/user/factories/factory_method_user.py`;
2. Modelagem dos dados e comportamentos das classes concretas em `backend/user/models.py`;
3. Criação de testes automatizados para validação das regras e consistência do padrão em `backend/user/tests.py`.

### Participantes

Os participantes da implementação deste Padrão de Projeto estão descritos na tabela abaixo:

<p style="text-align: center;">Tabela 1: Participantes da implementação do Factory Method</p>

|Matrícula | Aluno |
| -- | -- |
| 22/2015159  |  Lucas Guimarães Borges |
| 23/1026750  |  Ludmila Aysha Oliveira Nunes |

## Aplicação do _Factory Method_

### Modelagem UML

A Figura 1 (diagrama UML) demonstra a relação entre as classes, destacando a dependência das subclasses criadoras (`AdminCreator`, `StudentCreator`) em relação à superclasse `UserCreator`, bem como a associação entre os criadores e os produtos concretos (`Admin`, `Student`).

<p align="center" style="font-size: 12;">Figura 1: Modelagem UML do Factory Method</p>

![Modelagem UML do Factory Method](/../assets/factory-method-factory-method.drawio.png)

<p align="center" style="font-size: 8;"> Fonte: Criado em <a href="https://app.diagrams.net">diagrams.net</a> por Lucas Guimarães.</p>

### Implementação

A estrutura implementada pode ser resumida da seguinte forma:

```python
class UserCreator(ABC):
    @abstractmethod
    def create_user(self, *args, **kwargs):
        pass
```

A classe `UserCreator` define a interface do método-fábrica (`create_user`), que será obrigatoriamente sobrescrito nas subclasses concretas. Cada criador é responsável por instanciar um tipo específico de usuário:

```python
class StudentCreator(UserCreator):
    def create_user(self, name, email, phone, password, enrollment, enrollment_proof, bio=None, profile_photo_url="default"):
        return Student.objects.create(...)
```

```python
class AdminCreator(UserCreator):
    def create_user(self, name, email, phone, password, profile_photo_url="default"):
        return Admin.objects.create(...)
```

Através dessa estrutura, o código cliente não precisa conhecer diretamente as classes `Student` ou `Admin`. Ele apenas interage com um criador apropriado:

```python
student_creator = StudentCreator()
student = student_creator.create_user(...)
```

Dessa forma, a instanciação é encapsulada dentro das fábricas concretas, permitindo a expansão do sistema sem alterar o código existente, caso seja necessário adicionar novos tipos de usuários futuramente.

No arquivo `backend/user/models.py`, as classes `Student` e `Admin` estendem a classe abstrata `User`, herdando atributos e métodos comuns, como nome, e-mail e senha. A relação direta com o _Factory Method_ se dá pelo fato de que as fábricas manipulam diretamente as classes concretas, mas o cliente opera sobre a abstração (`UserCreator`).

### Códigos na Íntegra

A seguir, estão apresentados os códigos que implementa as classes relacionadas ao _Factory Method_ e o modelo de dados indicado.

*`user/factories/factory_method_user.py`*

<details>
    <summary>Clique aqui para ver o código inteiro</summary>

```python
from abc import ABC, abstractmethod
from user.models import Admin, Student


class UserCreator(ABC):
    
    @abstractmethod
    def create_user(self, *args, **kwargs):
        pass


class StudentCreator(UserCreator):
    def create_user(self, name, email, phone, password, enrollment, enrollment_proof, bio=None, profile_photo_url="default"):
        student = Student.objects.create(
            name=name,
            email=email,
            phone=phone,
            password=password,
            enrollment=enrollment,
            enrollment_proof=enrollment_proof,
            bio=bio,
            profile_photo_url=profile_photo_url
        )

        return student

class AdminCreator(UserCreator):
    def create_user(self, name, email, phone, password, profile_photo_url="default"):
        admin = Admin.objects.create(
            name=name,
            email=email,
            phone=phone,
            password=password,
            profile_photo_url=profile_photo_url
        )

        return admin
```
</details>

*`user/models.py`*

<details>
    <summary>Clique aqui para ver o código inteiro</summary>

```python
from django.db import models
from django.core.validators import RegexValidator, MinLengthValidator

class User(models.Model):
    name = models.CharField(max_length=100)
    email = models.EmailField(max_length=100)
    phone = models.CharField(
        max_length=11,
        validators=[RegexValidator(r'^\d{11}$', 'Telefone deve ter 11 dígitos, sem outros caracteres.')]
    )
    password = models.CharField(max_length=50)
    profile_photo_url = models.URLField(max_length=500, null=True, blank=True)

    class Meta:
        abstract = True
    
    def get_name(self):
        return self.name
    
    def set_name(self, name):
        self.name = name
    
    def get_email(self):
        return self.email
    
    # def set_email(self, email):
    #     self.email = email
    
    def get_phone(self):
        return self.phone
    
    def set_phone(self, phone):
        self.phone = phone

    def get_profile_photo_url(self):
        if self.profile_photo_url:
            return self.profile_photo_url
        return "colocar url de uma imagem padrao"
    
    def update_profile_photo_url(self, profile_photo_url):
        self.profile_photo_url = profile_photo_url
    
    def set_password(self, password):
        self.password = password
    
    def remove_profile_photo(self):
        if self.profile_photo_url != "colocar url de uma imagem padrao":
            self.profile_photo_url = "colocar url de uma imagem padrao"


class Student(User):
    enrollment = models.CharField(max_length=9)
    enrollment_proof = models.URLField(max_length=500)
    bio = models.TextField(null=True, blank=True)
    # published_products = a ser implementado

    def get_enrollment(self):
        return self.enrollment
    
    def get_enrollment_proof(self):
        return self.enrollment
    
    def get_bio(self):
        return self.bio
    
    def set_bio(self, bio):
        self.bio = bio
    
    def get_published_products(self):
        # return self.published_products.all() 
        ...
    
    # def delete_publication(self, publication: Publication)
    # a ser implementado

    # def evaluate()
    # a ser implementado

class Admin(User):
    
    def delete_product(self):
        pass

    def delete_student(self):
        pass

    def delete_publication(self):
        pass
```
</details>


## Verificação e Validação

A validação da implementação foi realizada por meio de testes unitários no Django (`backend/user/tests.py`), abrangendo:

- Criação de instâncias de `Student` e `Admin` pelas respectivas fábricas;
- Garantia de que `UserCreator` não pode ser instanciada diretamente (por ser abstrata);
- Testes de integridade para campos obrigatórios (_IntegrityError_);
- Testes de validação dos números de telefone (_ValidationError_).

### Passo-a-passo de execução dos testes

**1. Clonar o repositório**

Abra o terminal e execute:

```bash
git clone https://github.com/UnBArqDsw2025-2-Turma02/2025.2_T02_G6_AquiTemFCTE_Entrega_03.git
```

**2. Acessar o diretório do projeto**

```bash
cd 2025.2_T02_G6_AquiTemFCTE_Entrega_03
```

**3. Criar um ambiente virtual (_venv_)**

- Windows:

```bash
git clone https://github.com/UnBArqDsw2025-2-Turma02/2025.2_T02_G6_AquiTemFCTE_Entrega_03.git
```

- Linux/Mac:

```bash
python3 -m venv venv
```

**4. Ativar o ambiente virtual**

```bash
venv\Scripts\activate
```

- Linux/Mac:

```bash
source venv/bin/activate
```

**5. Instalar as dependências do projeto**

```bash
pip install -r requirements.txt
```

**6. Acessar a pasta do backend**

```bash
cd backend
```

**7. Executar os testes da aplicação**

Rode o seguinte comando:

```bash
python manage.py test user.tests -v 2
```

Ao rodá-los, o Django cria um banco de dados temporário e verifica se as fábricas e validações funcionam conforme o esperado, garantindo que o padrão _Factory Method_ foi corretamente aplicado e que as instâncias geradas são coerentes com o modelo de domínio.

## Vídeo de explicação

Abaixo, é possível assistir ao vídeo de explicação da aplicação do _Factory Method_

<iframe width="560" height="315" src="https://www.youtube.com/embed/gon2CrHGkao?si=6_0JObCPYF2gKG-s" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>

## Justificativas e Senso Crítico

A escolha do padrão _Factory Method_ se mostrou adequada para este contexto, pois:

- Encapsula a criação de objetos complexos, reduzindo a repetição de código de inicialização de usuários;
- Facilita a expansão do sistema, permitindo incluir novos papéis sem modificar as fábricas existentes;
- Garante coerência na criação de entidades, respeitando as validações e dependências definidas no modelo.

Em termos arquiteturais, a adoção do _Factory Method_ contribuiu para:

- Baixo acoplamento entre o cliente e as classes concretas;
- Alta coesão dentro das fábricas, que têm uma única responsabilidade;
- Maior testabilidade, pois as fábricas e modelos foram validados isoladamente.

Como limitação, observa-se que a quantidade de fábricas pode crescer conforme o sistema evolui, exigindo um gerenciamento cuidadoso de subclasses. Entretanto, essa característica é compensada pela clareza e manutenibilidade do código resultante.

## Conclusão

A implementação do padrão _Factory Method_ neste projeto garantiu uma criação estruturada e extensível de usuários dentro da plataforma AquiTemFCTE. O padrão possibilitou a separação entre lógica de criação e lógica de negócio, favorecendo a organização do código e a facilidade de manutenção.

A aplicação do padrão foi acompanhada de modelagem UML, implementação em código Python/Django e testes automatizados, o que assegura sua correta funcionalidade e aderência aos princípios da engenharia de software orientada a objetos.

## Referências

> LARMAN, Craig. **Utilizando UML e Padrões**: Uma Introdução a Análise e ao Projeto Orientado a Objetos. 3a. edição. Bookman, 2007. p. 453.

> SERRANO, Milene. **08a - Video-Aula - DSW - GoFs - Criacionais**. Microsoft Share Point, 3 de ago. de 2020. Disponível em: <[https://unbbr-my.sharepoint.com/:v:/g/personal/mileneserrano_unb_br/EU5BKTPMklpEumc9FmhiUl8BEbUb-xvaeNXahR4AhazeKQ?e=KQfXy2&nav=eyJyZWZlcnJhbEluZm8iOnsicmVmZXJyYWxBcHAiOiJTdHJlYW1XZWJBcHAiLCJyZWZlcnJhbFZpZXciOiJTaGFyZURpYWxvZy1MaW5rIiwicmVmZXJyYWxBcHBQbGF0Zm9ybSI6IldlYiIsInJlZmVycmFsTW9kZSI6InZpZXcifX0%3D](https://unbbr-my.sharepoint.com/:v:/g/personal/mileneserrano_unb_br/EU5BKTPMklpEumc9FmhiUl8BEbUb-xvaeNXahR4AhazeKQ?e=KQfXy2&nav=eyJyZWZlcnJhbEluZm8iOnsicmVmZXJyYWxBcHAiOiJTdHJlYW1XZWJBcHAiLCJyZWZlcnJhbFZpZXciOiJTaGFyZURpYWxvZy1MaW5rIiwicmVmZXJyYWxBcHBQbGF0Zm9ybSI6IldlYiIsInJlZmVycmFsTW9kZSI6InZpZXcifX0%3D)>. Acesso em: 12 de out. de 2025.

> SERRANO, Milene. **08b - Video-Aula - DSW - GoFs - Criacionais - MetodoFabrica**. Microsoft Share Point, 3 de ago. de 2020. Disponível em: <[https://unbbr-my.sharepoint.com/:v:/g/personal/mileneserrano_unb_br/EaEyZ8_0t2hBqxA18xigI3oBSHrxG6r4evdrZtsrDZelEQ?e=EHj7oI&nav=eyJyZWZlcnJhbEluZm8iOnsicmVmZXJyYWxBcHAiOiJTdHJlYW1XZWJBcHAiLCJyZWZlcnJhbFZpZXciOiJTaGFyZURpYWxvZy1MaW5rIiwicmVmZXJyYWxBcHBQbGF0Zm9ybSI6IldlYiIsInJlZmVycmFsTW9kZSI6InZpZXcifX0%3D](https://unbbr-my.sharepoint.com/:v:/g/personal/mileneserrano_unb_br/EaEyZ8_0t2hBqxA18xigI3oBSHrxG6r4evdrZtsrDZelEQ?e=EHj7oI&nav=eyJyZWZlcnJhbEluZm8iOnsicmVmZXJyYWxBcHAiOiJTdHJlYW1XZWJBcHAiLCJyZWZlcnJhbFZpZXciOiJTaGFyZURpYWxvZy1MaW5rIiwicmVmZXJyYWxBcHBQbGF0Zm9ybSI6IldlYiIsInJlZmVycmFsTW9kZSI6InZpZXcifX0%3D)>. Acesso em: 07 de out. de 2025.

> SERRANO, Milene. **Arquitetura e Desenho de Software:** AULA - GOFS CRIACIONAIS. Apresentação em PDF. Disponível em: <[https://aprender3.unb.br/pluginfile.php/3178542/mod_page/content/1/Arquitetura%20e%20Desenho%20de%20Software%20-%20Aula%20GoFs%20Criacionais%20-%20Profa.%20Milene.pdf](https://aprender3.unb.br/pluginfile.php/3178542/mod_page/content/1/Arquitetura%20e%20Desenho%20de%20Software%20-%20Aula%20GoFs%20Criacionais%20-%20Profa.%20Milene.pdf)>. Acesso em: 12 de out. de 2025.

## Histórico de Versões

| Versão | Data | Descrição | Autor(es) | Revisor(es) | Detalhes da Revisão |
| ------ | ---- | --------- | --------- | ----------- | ------------------- |
| 1.0    | 06/10/2025 | Primeira versão do Factory Method | [Lucas Guimarães](https://github.com/lcsgborges) | [Ludmila Nunes](https://github.com/ludmilaaysha) | Não há presença que abstração de classes e polimorfismo |
| 2.0    | 10/10/2025 | Segunda versão do Factory Method e modelagem no Draw.io | [Lucas Guimarães](https://github.com/lcsgborges) | [Ludmila Nunes](https://github.com/ludmilaaysha) | Alterações alinhadas e sem nenhum erro identificado |
| 2.1    | 12/10/2025 | Adição de casos de teste | [Ludmila Nunes](https://github.com/ludmilaaysha) | [Lucas Guimarães](https://github.com/lcsgborges) | Alterações alinhadas e sem nenhum erro identificado |
| 2.2    | 12/10/2025 | Redação da documentação | [Ludmila Nunes](https://github.com/ludmilaaysha) | [Lucas Guimarães](https://github.com/lcsgborges) | Link errado a ser consertado |
| 2.3    | 12/10/2025 | Conserta link quebrado | [Lucas Guimarães](https://github.com/lcsgborges) | [Ludmila Nunes](https://github.com/ludmilaaysha) | Alterações alinhadas e sem nenhum erro identificado |
| 2.4    | 14/10/2025 | Adiciona seção de códigos na íntegra | [Ludmila Nunes](https://github.com/ludmilaaysha) | [Lucas Guimarães](https://github.com/lcsgborges) | Alterações alinhadas e sem nenhum erro identificado |
| 2.5   | 16/10/2025 | Adiciona vídeo de explicação | [Ludmila Nunes](https://github.com/ludmilaaysha) | [Lucas Guimarães](https://github.com/lcsgborges) | Alterações alinhadas e sem nenhum erro identificado |
| 2.6   | 16/10/2025 | Melhora seção de passo-a-passo | [Ludmila Nunes](https://github.com/ludmilaaysha) | [Lucas Guimarães](https://github.com/lcsgborges) | Alterações alinhadas e sem nenhum erro identificado |
